From hjk@linutronix.de  Tue Feb 20 14:40:27 2007
From: Hans-Jürgen Koch <hjk@linutronix.de>
Date: Tue, 13 Feb 2007 15:01:48 +0100
Subject: UIO: update documentation for multiple mappings
To: Greg KH <greg@kroah.com>
Cc: tglx@linutronix.de, Benedikt Spranger <b.spranger@linutronix.de>
Message-ID: <200702131501.49296.hjk@linutronix.de>


here's a patch that updates the UIO docs. It adds the description of our new
multiple mapping capabilities.


Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 Documentation/DocBook/uio-howto.tmpl |  140 +++++++++++++++++++++++++----------
 1 file changed, 102 insertions(+), 38 deletions(-)

--- a/Documentation/DocBook/uio-howto.tmpl
+++ b/Documentation/DocBook/uio-howto.tmpl
@@ -30,6 +30,12 @@
 
 <revhistory>
 	<revision>
+	<revnumber>0.2</revnumber>
+	<date>2007-02-13</date>
+	<authorinitials>hjk</authorinitials>
+	<revremark>Update after multiple mappings were added.</revremark>
+	</revision>
+	<revision>
 	<revnumber>0.1</revnumber>
 	<date>2006-12-11</date>
 	<authorinitials>hjk</authorinitials>
@@ -76,12 +82,11 @@ interested in translating it, please ema
 	like this are for industrial I/O cards.
 	</para>
 	<para>
-	To address this situation, and create the userspace I/O system
-	(UIO) was designed.  For typical industrial I/O cards, only a
-	very small kernel module is needed. The main part of the
-	driver will run in user space. This simplifies development and
-	reduces the risk of serious bugs within a kernel
-	module.
+	To address this situation, the userspace I/O system (UIO) was
+	designed.  For typical industrial I/O cards, only a very small
+	kernel module is needed. The main part of the driver will run in
+	user space. This simplifies development and reduces the risk of
+	serious bugs within a kernel module.
 	</para>
 </sect2>
 
@@ -193,18 +198,6 @@ interested in translating it, please ema
 </listitem>
 <listitem>
 	<para>
-	<filename>addr</filename>: The address of memory that can be
-	mapped. This file will only appear if the address is not NULL.
-	</para>
-</listitem>
-<listitem>
-	<para>
-	<filename>size</filename>: The size, in bytes, of the memory
-	pointed to by addr. This file only appears if size is not 0.
-	</para>
-</listitem>
-<listitem>
-	<para>
 	<filename>version</filename>: A version string defined by your
 	driver. This allows the user space part of your driver to deal
 	with different versions of the kernel module.
@@ -218,14 +211,53 @@ interested in translating it, please ema
 	</para>
 </listitem>
 </itemizedlist>
-
-	<para>
+<para>
 	These attributes appear under the
 	<filename>/sys/class/uio/uioX</filename> directory.  Please
 	note that this directory might be a symlink, and not a real
 	directory.  Any userspace code that accesses it must be able
-	to handle this.)
+	to handle this.
+</para>
+<para>
+	Each UIO device can make one or more memory regions available for
+	memory mapping. This is necessary because some industrial I/O cards
+	require access to more than one PCI memory region in a driver.
+</para>
+<para>
+	Each mapping has its own directory in sysfs, the first mapping
+	appears as <filename>/sys/class/uio/uioX/maps/map0/</filename>.
+	Subsequent mappings create directories <filename>map1/</filename>,
+	<filename>map2/</filename>, and so on. These directories will only
+	appear if the size of the mapping is not 0.
+</para>
+<para>
+	Each <filename>mapX/</filename> directory contains two read-only files
+	that show start address and size of the memory:
+</para>
+<itemizedlist>
+<listitem>
+	<para>
+	<filename>addr</filename>: The address of memory that can be mapped.
 	</para>
+</listitem>
+<listitem>
+	<para>
+	<filename>size</filename>: The size, in bytes, of the memory
+	pointed to by addr.
+	</para>
+</listitem>
+</itemizedlist>
+
+<para>
+	From userspace, the different mappings are distinguished by adjusting
+	the <varname>offset</varname> parameter of the
+	<function>mmap()</function> call. To map the memory of mapping N, you
+	have to use N times the page size as your offset:
+</para>
+<programlisting format="linespecific">
+offset = N * getpagesize();
+</programlisting>
+
 </sect2>
 </sect1>
 
@@ -309,23 +341,10 @@ it will appear in sysfs. I recommend usi
 </listitem>
 
 <listitem>
-<varname>int memtype</varname>: Required if you have memory that can be
-mapped with <function>mmap()</function>. Set this to
-<varname>UIO_MEM_PHYS</varname> if you you have physical memory on your
-card to be mapped. Use <varname>UIO_MEM_LOGICAL</varname> for logical
-memory (e.g. allocated with <function>kmalloc()</function>).
-</listitem>
-
-<listitem>
-<varname>unsigned long addr</varname>: Required if you have memory that
-can be mapped with <function>mmap()</function>. Fill in the address of
-your memory block.
-</listitem>
-
-<listitem>
-<varname>unsigned long size</varname>: Required if you have memory that
-can be mapped with <function>mmap()</function>. Fill in the size of the
-memory block that <varname>addr</varname> points to.
+<varname>struct uio_mem mem[ MAX_UIO_MAPS ]</varname>: Required if you
+have memory that can be mapped with <function>mmap()</function>. For each
+mapping you need to fill one of the <varname>uio_mem</varname> structures.
+See the description below for details.
 </listitem>
 
 <listitem>
@@ -367,8 +386,53 @@ device is actually used.
 <function>open()</function>, you will probably also want a custom
 <function>release()</function> function.
 </listitem>
+</itemizedlist>
 
+<para>
+Usually, your device will have one or more memory regions that can be mapped
+to user space. For each region, you have to set up a
+<varname>struct uio_mem</varname> in the <varname>mem[]</varname> array.
+Here's a description of the fields of <varname>struct uio_mem</varname>:
+</para>
+
+<itemizedlist>
+<listitem>
+<varname>int memtype</varname>: Required if the mapping is used. Set this to
+<varname>UIO_MEM_PHYS</varname> if you you have physical memory on your
+card to be mapped. Use <varname>UIO_MEM_LOGICAL</varname> for logical
+memory (e.g. allocated with <function>kmalloc()</function>). There's also
+<varname>UIO_MEM_VIRTUAL</varname> for virtual memory.
+</listitem>
+
+<listitem>
+<varname>unsigned long addr</varname>: Required if the mapping is used.
+Fill in the address of your memory block. This address is the one that
+appears in sysfs.
+</listitem>
+
+<listitem>
+<varname>unsigned long size</varname>: Fill in the size of the
+memory block that <varname>addr</varname> points to. If <varname>size</varname>
+is zero, the mapping is considered unused. Note that you
+<emphasis>must</emphasis> initialize <varname>size</varname> with zero for
+all unused mappings.
+</listitem>
+
+<listitem>
+<varname>void *internal_addr</varname>: If you have to access this memory
+region from within your kernel module, you will want to map it internally by
+using something like <function>ioremap_nocache()</function>. Addresses
+returned by this function can not be mapped to user space, so you must not
+store it in <varname>addr</varname>. Use <varname>internal_addr</varname>
+instead to remember such an address.
+</listitem>
 </itemizedlist>
+
+<para>
+Please do not touch the <varname>kobj</varname> element of
+<varname>struct uio_mem</varname>! It is used by the UIO framework
+to set up sysfs files for this mapping. Simply leave it alone.
+</para>
 </sect2>
 
 <sect2 id="adding_irq_handler">
