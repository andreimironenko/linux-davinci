From linux-pm-bounces@lists.osdl.org Mon Sep 12 21:30:53 2005
From: David Brownell <david-b@pacbell.net>
Date: Mon, 12 Sep 2005 19:39:39 -0700
Message-Id: <200509121939.39358.david-b@pacbell.net>
Subject: [linux-pm] [patch 2/3] usb device wakeup flags


This patch teaches "usb_device" about the new driver model wakeup support:

 - It updates device wakeup capabilities when entering a configuration
   with the WAKEUP attribute;

 - During suspend processing it consults the policy bit to see
   whether it should enable wakeup for that device.  (This resolves
   a FIXME to not assume the answer is always "yes"; some devices
   lie about supporting remote wakeup.)

Support for root hubs and the HCDs is separate (and more complex).

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/hub.c |   16 +++++++++-------
 1 file changed, 9 insertions(+), 7 deletions(-)

--- gregkh-2.6.orig/drivers/usb/core/hub.c
+++ gregkh-2.6/drivers/usb/core/hub.c
@@ -1020,9 +1020,15 @@ void usb_set_device_state(struct usb_dev
 	spin_lock_irqsave(&device_state_lock, flags);
 	if (udev->state == USB_STATE_NOTATTACHED)
 		;	/* do nothing */
-	else if (new_state != USB_STATE_NOTATTACHED)
+	else if (new_state != USB_STATE_NOTATTACHED) {
 		udev->state = new_state;
-	else
+		if (new_state == USB_STATE_CONFIGURED)
+			device_init_wakeup(&udev->dev,
+				(udev->actconfig->desc.bmAttributes
+				 & USB_CONFIG_ATT_WAKEUP));
+		else if (new_state != USB_STATE_SUSPENDED)
+			device_init_wakeup(&udev->dev, 0);
+	} else
 		recursively_mark_NOTATTACHED(udev);
 	spin_unlock_irqrestore(&device_state_lock, flags);
 }
@@ -1546,11 +1552,7 @@ static int hub_port_suspend(struct usb_h
 	 * NOTE:  OTG devices may issue remote wakeup (or SRP) even when
 	 * we don't explicitly enable it here.
 	 */
-	if (udev->actconfig
-			// && FIXME (remote wakeup enabled on this bus)
-			// ... currently assuming it's always appropriate
-			&& (udev->actconfig->desc.bmAttributes
-				& USB_CONFIG_ATT_WAKEUP) != 0) {
+	if (device_may_wakeup(&udev->dev)) {
 		status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
 				USB_DEVICE_REMOTE_WAKEUP, 0,
