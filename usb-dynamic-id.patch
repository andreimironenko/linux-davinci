---
 drivers/usb/core/usb.c |   12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

--- gregkh-2.6.orig/drivers/usb/core/usb.c
+++ gregkh-2.6/drivers/usb/core/usb.c
@@ -104,7 +104,7 @@ static int usb_probe_interface(struct de
 	if (interface_to_usbdev(intf)->state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
 
-	id = usb_match_id (intf, driver->id_table);
+	id = usb_match_id(intf, driver->id_table);
 	if (id) {
 		dev_dbg (dev, "%s - got id\n", __FUNCTION__);
 
@@ -386,7 +386,7 @@ void usb_driver_release_interface(struct
  * only a nonzero "driver_info" field.  If you do this, the USB device
  * driver's probe() routine should use additional intelligence to
  * decide whether to bind to the specified interface.
- * 
+ *
  * What Makes Good usb_device_id Tables:
  *
  * The match algorithm is very simple, so that intelligence in
@@ -407,19 +407,19 @@ void usb_driver_release_interface(struct
  * are slightly more general; use the USB_DEVICE_INFO macro, or
  * its siblings.  These are used with single-function devices
  * where bDeviceClass doesn't specify that each interface has
- * its own class. 
+ * its own class.
  *
  * Matches based on interface class/subclass/protocol are the
  * most general; they let drivers bind to any interface on a
  * multiple-function device.  Use the USB_INTERFACE_INFO
- * macro, or its siblings, to match class-per-interface style 
+ * macro, or its siblings, to match class-per-interface style
  * devices (as recorded in bDeviceClass).
- *  
+ *
  * Within those groups, remember that not all combinations are
  * meaningful.  For example, don't give a product version range
  * without vendor and product IDs; or specify a protocol without
  * its associated class and subclass.
- */   
+ */
 const struct usb_device_id *
 usb_match_id(struct usb_interface *interface, const struct usb_device_id *id)
 {
