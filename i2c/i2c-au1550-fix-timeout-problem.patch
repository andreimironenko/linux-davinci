From khali@linux-fr.org Sun Aug 13 14:35:46 2006
Date: Sun, 13 Aug 2006 23:35:40 +0200
From: Domen Puncer <domen.puncer@ultra.si>
To: Greg KH <greg@kroah.com>
Cc: Domen Puncer <domen.puncer@ultra.si>
Subject: [PATCH 04/12] i2c-au1550: Fix timeout problem
Message-Id: <20060813233540.ec45adfe.khali@linux-fr.org>
Content-Disposition: inline; filename=i2c-au1550-fix-timeout-problem.patch

From: Domen Puncer <domen.puncer@ultra.si>

i2c-au1550: Fix timeout problem

Fix from Jordan Crouse:
If the transmit and recieve FIFOS are not empty, forceably flush them
rather then waiting for them to drain on their own.

This solves at least a problem reported by Clem Taylor:
http://www.linux-mips.org/archives/linux-mips/2006-05/msg00240.html
(1% of I2C transactions would timeout)

Signed-off-by: Domen Puncer <domen.puncer@ultra.si>
Signed-off-by: Jean Delvare <khali@linux-fr.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/i2c/busses/i2c-au1550.c |   14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

--- gregkh-2.6.orig/drivers/i2c/busses/i2c-au1550.c
+++ gregkh-2.6/drivers/i2c/busses/i2c-au1550.c
@@ -118,13 +118,19 @@ do_address(struct i2c_au1550_data *adap,
 
 	/* Reset the FIFOs, clear events.
 	*/
-	sp->psc_smbpcr = PSC_SMBPCR_DC;
+	stat = sp->psc_smbstat;
 	sp->psc_smbevnt = PSC_SMBEVNT_ALLCLR;
 	au_sync();
-	do {
-		stat = sp->psc_smbpcr;
+
+	if (!(stat & PSC_SMBSTAT_TE) || !(stat & PSC_SMBSTAT_RE)) {
+		sp->psc_smbpcr = PSC_SMBPCR_DC;
 		au_sync();
-	} while ((stat & PSC_SMBPCR_DC) != 0);
+		do {
+			stat = sp->psc_smbpcr;
+			au_sync();
+		} while ((stat & PSC_SMBPCR_DC) != 0);
+		udelay(50);
+	}
 
 	/* Write out the i2c chip address and specify operation
 	*/
