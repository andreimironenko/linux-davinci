From michael@ozlabs.org Thu Mar 22 03:53:43 2007
From: Michael Ellerman <michael@ellerman.id.au>
To: linux-pci@atrey.karlin.mff.cuni.cz
CC: Greg Kroah-Hartman <greg@kroah.com>,
	Eric W. Biederman <ebiederm@xmission.com>,
	David S. Miller <davem@davemloft.net>,
	Benjamin Herrenschmidt <benh@kernel.crashing.org>,
	Andrew Morton <akpm@osdl.org>,
	<daniel.e.wolstenholme@intel.com>
Date: Thu, 22 Mar 2007 21:51:36 +1100
Subject: MSI: Remove msi_cache
Message-Id: <20070322105339.D3A36DDF53@ozlabs.org>

We don't need a special cache just for msi descriptors. They're not
particularly large, under 100 bytes for sure, and don't seem to require any
special alignment etc. On most systems there will be relatively few MSIs,
and hence we waste most of a page on the cache. Better to just kzalloc the
space for the few we do need.

Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/msi.c |   44 ++++----------------------------------------
 1 file changed, 4 insertions(+), 40 deletions(-)

--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -24,20 +24,8 @@
 #include "pci.h"
 #include "msi.h"
 
-static struct kmem_cache* msi_cachep;
-
 static int pci_msi_enable = 1;
 
-static int msi_cache_init(void)
-{
-	msi_cachep = kmem_cache_create("msi_cache", sizeof(struct msi_desc),
-					0, SLAB_HWCACHE_ALIGN, NULL, NULL);
-	if (!msi_cachep)
-		return -ENOMEM;
-
-	return 0;
-}
-
 static void msi_set_enable(struct pci_dev *dev, int enable)
 {
 	int pos;
@@ -195,28 +183,12 @@ void unmask_msi_irq(unsigned int irq)
 
 static int msi_free_irq(struct pci_dev* dev, int irq);
 
-static int msi_init(void)
-{
-	static int status = -ENOMEM;
-
-	if (!status)
-		return status;
-
-	status = msi_cache_init();
-	if (status < 0) {
-		pci_msi_enable = 0;
-		printk(KERN_WARNING "PCI: MSI cache init failed\n");
-		return status;
-	}
-
-	return status;
-}
 
 static struct msi_desc* alloc_msi_entry(void)
 {
 	struct msi_desc *entry;
 
-	entry = kmem_cache_zalloc(msi_cachep, GFP_KERNEL);
+	entry = kzalloc(sizeof(struct msi_desc), GFP_KERNEL);
 	if (!entry)
 		return NULL;
 
@@ -342,7 +314,7 @@ static int msi_capability_init(struct pc
 	/* Configure MSI capability structure */
 	irq = arch_setup_msi_irq(dev, entry);
 	if (irq < 0) {
-		kmem_cache_free(msi_cachep, entry);
+		kfree(entry);
 		return irq;
 	}
 	entry->link.head = irq;
@@ -415,7 +387,7 @@ static int msix_capability_init(struct p
 		/* Configure MSI-X capability structure */
 		irq = arch_setup_msi_irq(dev, entry);
 		if (irq < 0) {
-			kmem_cache_free(msi_cachep, entry);
+			kfree(entry);
 			break;
 		}
  		entries[i].vector = irq;
@@ -504,10 +476,6 @@ int pci_enable_msi(struct pci_dev* dev)
 	if (pci_msi_supported(dev) < 0)
 		return -EINVAL;
 
-	status = msi_init();
-	if (status < 0)
-		return status;
-
 	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
 	if (!pos)
 		return -EINVAL;
@@ -578,7 +546,7 @@ static int msi_free_irq(struct pci_dev* 
 	get_irq_msi(entry->link.tail)->link.head = entry->link.head;
 
 	arch_teardown_msi_irq(irq);
-	kmem_cache_free(msi_cachep, entry);
+	kfree(entry);
 
 	if (type == PCI_CAP_ID_MSIX) {
 		writel(1, base + entry_nr * PCI_MSIX_ENTRY_SIZE +
@@ -615,10 +583,6 @@ int pci_enable_msix(struct pci_dev* dev,
 	if (!entries || pci_msi_supported(dev) < 0)
  		return -EINVAL;
 
-	status = msi_init();
-	if (status < 0)
-		return status;
-
 	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
 	if (!pos)
  		return -EINVAL;
