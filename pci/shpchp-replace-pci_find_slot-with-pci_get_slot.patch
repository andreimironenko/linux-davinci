From kaneshige.kenji@jp.fujitsu.com Thu Nov 24 19:27:04 2005
Message-ID: <43868335.3080001@jp.fujitsu.com>
Date: Fri, 25 Nov 2005 12:21:25 +0900
From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
To: Greg KH <greg@kroah.com>
CC: <kristen.c.accardi@intel.com>
Subject: shpchp: replace pci_find_slot() with pci_get_slot()


This patch replaces pci_find_slot() with pci_get_slot() in the SHPCHP
driver. This enables SHPCHP driver to work on multiple PCI segment
systems.

Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/pci/hotplug/shpchp_pci.c |   19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp_pci.c
+++ gregkh-2.6/drivers/pci/hotplug/shpchp_pci.c
@@ -89,10 +89,11 @@ int shpchp_configure_device(struct slot 
 	struct pci_bus *parent = p_slot->ctrl->pci_dev->subordinate;
 	int num, fn;
 
-	dev = pci_find_slot(p_slot->bus, PCI_DEVFN(p_slot->device, 0));
+	dev = pci_get_slot(parent, PCI_DEVFN(p_slot->device, 0));
 	if (dev) {
 		err("Device %s already exists at %x:%x, cannot hot-add\n",
 				pci_name(dev), p_slot->bus, p_slot->device);
+		pci_dev_put(dev);
 		return -EINVAL;
 	}
 
@@ -103,12 +104,13 @@ int shpchp_configure_device(struct slot 
 	}
 
 	for (fn = 0; fn < 8; fn++) {
-		if (!(dev = pci_find_slot(p_slot->bus,
-					PCI_DEVFN(p_slot->device, fn))))
+		dev = pci_get_slot(parent, PCI_DEVFN(p_slot->device, fn));
+		if (!dev)
 			continue;
 		if ((dev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {
 			err("Cannot hot-add display device %s\n",
 					pci_name(dev));
+			pci_dev_put(dev);
 			continue;
 		}
 		if ((dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) ||
@@ -124,18 +126,21 @@ int shpchp_configure_device(struct slot 
 			}
 			if (busnr >= end) {
 				err("No free bus for hot-added bridge\n");
+				pci_dev_put(dev);
 				continue;
 			}
 			child = pci_add_new_bus(parent, dev, busnr);
 			if (!child) {
 				err("Cannot add new bus for %s\n",
 						pci_name(dev));
+				pci_dev_put(dev);
 				continue;
 			}
 			child->subordinate = pci_do_scan_bus(child);
 			pci_bus_size_bridges(child);
 		}
 		program_fw_provided_values(dev);
+		pci_dev_put(dev);
 	}
 
 	pci_bus_assign_resources(parent);
@@ -149,17 +154,19 @@ int shpchp_unconfigure_device(struct slo
 	int rc = 0;
 	int j;
 	u8 bctl = 0;
-	
+	struct pci_bus *parent = p_slot->ctrl->pci_dev->subordinate;
+
 	dbg("%s: bus/dev = %x/%x\n", __FUNCTION__, p_slot->bus, p_slot->device);
 
 	for (j=0; j<8 ; j++) {
-		struct pci_dev* temp = pci_find_slot(p_slot->bus,
+		struct pci_dev* temp = pci_get_slot(parent,
 				(p_slot->device << 3) | j);
 		if (!temp)
 			continue;
 		if ((temp->class >> 16) == PCI_BASE_CLASS_DISPLAY) {
 			err("Cannot remove display device %s\n",
 					pci_name(temp));
+			pci_dev_put(temp);
 			continue;
 		}
 		if (temp->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
@@ -167,10 +174,12 @@ int shpchp_unconfigure_device(struct slo
 			if (bctl & PCI_BRIDGE_CTL_VGA) {
 				err("Cannot remove display device %s\n",
 						pci_name(temp));
+				pci_dev_put(temp);
 				continue;
 			}
 		}
 		pci_remove_bus_device(temp);
+		pci_dev_put(temp);
 	}
 	return rc;
 }
