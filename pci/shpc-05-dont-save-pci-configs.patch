From rshah1@unix-os.sc.intel.com Thu Oct 13 13:21:06 2005
Message-Id: <20051013190821.552623698@csdlinux-2.jf.intel.com>
Date: Thu, 13 Oct 2005 12:05:40 -0700
From: rajesh.shah@intel.com
To: kristen.c.accardi@intel.com, gregkh@suse.de
Cc: david.keck@amd.com, akpm@osdl.org, Rajesh Shah <rajesh.shah@intel.com>
Subject: [patch 5/9] shpchp: dont save PCI config for hotplug slots/devices
Content-Disposition: inline; filename=shpc-05-dont-save-pci-configs.patch

This patch eliminates saving the PCI config header for devices
in hotplug capable slots. We now use the PCI core to get the
specific parts of the config header as required.

Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/hotplug/shpchp.h      |    1 
 drivers/pci/hotplug/shpchp_core.c |    7 
 drivers/pci/hotplug/shpchp_ctrl.c |   48 +++--
 drivers/pci/hotplug/shpchp_pci.c  |  314 --------------------------------------
 4 files changed, 32 insertions(+), 338 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp.h
+++ gregkh-2.6/drivers/pci/hotplug/shpchp.h
@@ -63,7 +63,6 @@ struct pci_func {
 	u8 switch_save;
 	u8 presence_save;
 	u8 pwr_save;
-	u32 config_space[0x20];
 	struct pci_dev* pci_dev;
 };
 
--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp_core.c
+++ gregkh-2.6/drivers/pci/hotplug/shpchp_core.c
@@ -424,13 +424,6 @@ static int shpc_probe(struct pci_dev *pd
 	first_device_num = ctrl->slot_device_offset;
 	num_ctlr_slots = ctrl->num_slots;
 
-	/* Store PCI Config Space for all devices on this bus */
-	rc = shpchp_save_config(ctrl, ctrl->slot_bus, num_ctlr_slots, first_device_num);
-	if (rc) {
-		err("%s: unable to save PCI configuration data, error %d\n", __FUNCTION__, rc);
-		goto err_out_free_ctrl_bus;
-	}
-
 	ctrl->add_support = 1;
 	
 	/* Setup the slot information structures */
--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp_ctrl.c
+++ gregkh-2.6/drivers/pci/hotplug/shpchp_ctrl.c
@@ -328,21 +328,20 @@ static int slot_remove(struct pci_func *
 /**
  * bridge_slot_remove - Removes a node from the linked list of slots.
  * @bridge: bridge to remove
+ * @secondaryBus: secondary PCI bus number for bridge being removed
+ * @subordinateBus: subordinate PCI bus number for bridge being removed
  *
  * Returns 0 if successful, !0 otherwise.
  */
-static int bridge_slot_remove(struct pci_func *bridge)
+static int bridge_slot_remove(struct pci_func *bridge, u8 secondaryBus,
+		u8 subordinateBus)
 {
-	u8 subordinateBus, secondaryBus;
 	u8 tempBus;
 	struct pci_func *next;
 
 	if (bridge == NULL)
 		return(1);
 
-	secondaryBus = (bridge->config_space[0x06] >> 8) & 0xFF;
-	subordinateBus = (bridge->config_space[0x06] >> 16) & 0xFF;
-
 	for (tempBus = secondaryBus; tempBus <= subordinateBus; tempBus++) {
 		next = shpchp_slot_list[tempBus];
 
@@ -410,16 +409,23 @@ struct pci_func *shpchp_slot_find(u8 bus
 	return(NULL);
 }
 
-static int is_bridge(struct pci_func * func)
+static int is_bridge(struct pci_func *func, struct controller *ctrl)
 {
-	/* Check the header type */
-	if (((func->config_space[0x03] >> 16) & 0xFF) == 0x01)
+	u8 hdr_type;
+	struct pci_bus *bus = ctrl->pci_dev->subordinate;
+
+	/*
+	 * Note: device may have just been hot-added and not yet scanned
+	 * by the pci core, so its pci_dev structure may not exist yet
+	 */
+	pci_bus_read_config_byte(bus, PCI_DEVFN(func->device, func->function),
+			PCI_HEADER_TYPE, &hdr_type);
+	if ((hdr_type & 0x7f) == PCI_HEADER_TYPE_BRIDGE)
 		return 1;
 	else
 		return 0;
 }
 
-
 /* The following routines constitute the bulk of the 
    hotplug controller logic
  */
@@ -709,8 +715,6 @@ static u32 board_added(struct pci_func *
 		goto err_exit;
 	}
 
-	shpchp_save_slot_config(ctrl, func);
-
 	func->status = 0;
 	func->switch_save = 0x10;
 	func->is_a_board = 0x01;
@@ -769,10 +773,18 @@ static u32 remove_board(struct pci_func 
 	u8 hp_slot;
 	u32 rc;
 	struct slot *p_slot;
+	u8 secondary = 0, subordinate = 0;
+	int remove_bridge;
 
 	if (func == NULL)
 		return(1);
 
+	if ((remove_bridge = is_bridge(func, ctrl))) {
+		/* Stash away bus information before we destroy it */
+		secondary = func->pci_dev->subordinate->secondary;
+		subordinate = func->pci_dev->subordinate->subordinate;
+	}
+
 	if (shpchp_unconfigure_device(func))
 		return(1);
 
@@ -825,10 +837,11 @@ static u32 remove_board(struct pci_func 
 
 	if (ctrl->add_support) {
 		while (func) {
-			if (is_bridge(func)) {
+			if (remove_bridge) {
 				dbg("PCI Bridge Hot-Remove s:b:d:f(%02x:%02x:%02x:%02x)\n", ctrl->seg, func->bus, 
 					func->device, func->function);
-				bridge_slot_remove(func);
+				bridge_slot_remove(func, secondary,
+						subordinate);
 			} else
 				dbg("PCI Function Hot-Remove s:b:d:f(%02x:%02x:%02x:%02x)\n", ctrl->seg, func->bus, 
 					func->device, func->function);
@@ -1185,9 +1198,12 @@ int shpchp_enable_slot (struct slot *p_s
 
 	rc = board_added(func, p_slot->ctrl);
 	if (rc) {
-		if (is_bridge(func))
-			bridge_slot_remove(func);
-		else
+		if (is_bridge(func, p_slot->ctrl)) {
+			u8 secondary = func->pci_dev->subordinate->secondary;
+			u8 subordinate =
+				func->pci_dev->subordinate->subordinate;
+			bridge_slot_remove(func, secondary, subordinate);
+		} else
 			slot_remove(func);
 
 		/* Setup slot structure with entry for empty slot */
--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp_pci.c
+++ gregkh-2.6/drivers/pci/hotplug/shpchp_pci.c
@@ -166,317 +166,3 @@ int shpchp_unconfigure_device(struct pci
 	return rc;
 }
 
-/* More PCI configuration routines; this time centered around hotplug controller */
-
-
-/*
- * shpchp_save_config
- *
- * Reads configuration for all slots in a PCI bus and saves info.
- *
- * Note:  For non-hot plug busses, the slot # saved is the device #
- *
- * returns 0 if success
- */
-int shpchp_save_config(struct controller *ctrl, int busnumber, int num_ctlr_slots, int first_device_num)
-{
-	int rc;
-	u8 class_code;
-	u8 header_type;
-	u32 ID;
-	u8 secondary_bus;
-	struct pci_func *new_slot;
-	int sub_bus;
-	int FirstSupported;
-	int LastSupported;
-	int max_functions;
-	int function;
-	u8 DevError;
-	int device = 0;
-	int cloop = 0;
-	int stop_it;
-	int index;
-	int is_hot_plug = num_ctlr_slots || first_device_num;
-	struct pci_bus lpci_bus, *pci_bus;
-
-	dbg("%s: num_ctlr_slots = %d, first_device_num = %d\n", __FUNCTION__,
-				num_ctlr_slots, first_device_num);
-
-	memcpy(&lpci_bus, ctrl->pci_dev->subordinate, sizeof(lpci_bus));
-	pci_bus = &lpci_bus;
-
-	dbg("%s: num_ctlr_slots = %d, first_device_num = %d\n", __FUNCTION__,
-				num_ctlr_slots, first_device_num);
-
-	/*   Decide which slots are supported */
-	if (is_hot_plug) {
-		/*********************************
-		 *  is_hot_plug is the slot mask
-		 *********************************/
-		FirstSupported = first_device_num;
-		LastSupported = FirstSupported + num_ctlr_slots - 1;
-	} else {
-		FirstSupported = 0;
-		LastSupported = 0x1F;
-	}
-
-	dbg("FirstSupported = %d, LastSupported = %d\n", FirstSupported,
-					LastSupported);
-
-	/*   Save PCI configuration space for all devices in supported slots */
-	pci_bus->number = busnumber;
-	for (device = FirstSupported; device <= LastSupported; device++) {
-		ID = 0xFFFFFFFF;
-		rc = pci_bus_read_config_dword(pci_bus, PCI_DEVFN(device, 0),
-					PCI_VENDOR_ID, &ID);
-
-		if (ID != 0xFFFFFFFF) {	  /*  device in slot */
-			rc = pci_bus_read_config_byte(pci_bus, PCI_DEVFN(device, 0),
-					0x0B, &class_code);
-			if (rc)
-				return rc;
-
-			rc = pci_bus_read_config_byte(pci_bus, PCI_DEVFN(device, 0),
-					PCI_HEADER_TYPE, &header_type);
-			if (rc)
-				return rc;
-
-			dbg("class_code = %x, header_type = %x\n", class_code, header_type);
-
-			/* If multi-function device, set max_functions to 8 */
-			if (header_type & 0x80)
-				max_functions = 8;
-			else
-				max_functions = 1;
-
-			function = 0;
-
-			do {
-				DevError = 0;
-
-				if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {   /* P-P Bridge */
-					/* Recurse the subordinate bus
-					 * get the subordinate bus number
-					 */
-					rc = pci_bus_read_config_byte(pci_bus,
-						PCI_DEVFN(device, function), 
-						PCI_SECONDARY_BUS, &secondary_bus);
-					if (rc) {
-						return rc;
-					} else {
-						sub_bus = (int) secondary_bus;
-
-						/* Save secondary bus cfg spc with this recursive call. */
-						rc = shpchp_save_config(ctrl, sub_bus, 0, 0);
-						if (rc)
-							return rc;
-					}
-				}
-
-				index = 0;
-				new_slot = shpchp_slot_find(busnumber, device, index++);
-
-				dbg("new_slot = %p\n", new_slot);
-
-				while (new_slot && (new_slot->function != (u8) function)) {
-					new_slot = shpchp_slot_find(busnumber, device, index++);
-					dbg("new_slot = %p\n", new_slot);
-				}
-				if (!new_slot) {
-					/* Setup slot structure. */
-					new_slot = shpchp_slot_create(busnumber);
-					dbg("new_slot = %p\n", new_slot);
-
-					if (new_slot == NULL)
-						return(1);
-				}
-
-				new_slot->bus = (u8) busnumber;
-				new_slot->device = (u8) device;
-				new_slot->function = (u8) function;
-				new_slot->is_a_board = 1;
-				new_slot->switch_save = 0x10;
-				new_slot->pwr_save = 1;
-				/* In case of unsupported board */
-				new_slot->status = DevError;
-				new_slot->pci_dev = pci_find_slot(new_slot->bus,
-					(new_slot->device << 3) | new_slot->function);
-				dbg("new_slot->pci_dev = %p\n", new_slot->pci_dev);
-
-				for (cloop = 0; cloop < 0x20; cloop++) {
-					rc = pci_bus_read_config_dword(pci_bus,
-						PCI_DEVFN(device, function), 
-						cloop << 2,
-						(u32 *) &(new_slot->config_space [cloop]));
-					/* dbg("new_slot->config_space[%x] = %x\n",
-						cloop, new_slot->config_space[cloop]); */
-					if (rc)
-						return rc;
-				}
-
-				function++;
-
-				stop_it = 0;
-
-				/*  this loop skips to the next present function
-				 *  reading in Class Code and Header type.
-				 */
-
-				while ((function < max_functions)&&(!stop_it)) {
-					rc = pci_bus_read_config_dword(pci_bus,
-						PCI_DEVFN(device, function),
-						PCI_VENDOR_ID, &ID);
-
-					if (ID == 0xFFFFFFFF) {  /* nothing there. */
-						function++;
-						dbg("Nothing there\n");
-					} else {  /* Something there */
-						rc = pci_bus_read_config_byte(pci_bus,
-							PCI_DEVFN(device, function), 
-							0x0B, &class_code);
-						if (rc)
-							return rc;
-
-						rc = pci_bus_read_config_byte(pci_bus,
-							PCI_DEVFN(device, function), 
-							PCI_HEADER_TYPE, &header_type);
-						if (rc)
-							return rc;
-
-						dbg("class_code = %x, header_type = %x\n",
-							class_code, header_type);
-						stop_it++;
-					}
-				}
-
-			} while (function < max_functions);
-			/* End of IF (device in slot?) */
-		} else if (is_hot_plug) {
-			/* Setup slot structure with entry for empty slot */
-			new_slot = shpchp_slot_create(busnumber);
-
-			if (new_slot == NULL) {
-				return(1);
-			}
-			dbg("new_slot = %p\n", new_slot);
-
-			new_slot->bus = (u8) busnumber;
-			new_slot->device = (u8) device;
-			new_slot->function = 0;
-			new_slot->is_a_board = 0;
-			new_slot->presence_save = 0;
-			new_slot->switch_save = 0;
-		}
-	}			/* End of FOR loop */
-
-	return(0);
-}
-
-
-/*
- * shpchp_save_slot_config
- *
- * Saves configuration info for all PCI devices in a given slot
- * including subordinate busses.
- *
- * returns 0 if success
- */
-int shpchp_save_slot_config(struct controller *ctrl, struct pci_func * new_slot)
-{
-	int rc;
-	u8 class_code;
-	u8 header_type;
-	u32 ID;
-	u8 secondary_bus;
-	int sub_bus;
-	int max_functions;
-	int function;
-	int cloop = 0;
-	int stop_it;
-	struct pci_bus lpci_bus, *pci_bus;
-	memcpy(&lpci_bus, ctrl->pci_dev->subordinate, sizeof(lpci_bus));
-	pci_bus = &lpci_bus;
-	pci_bus->number = new_slot->bus;
-
-	ID = 0xFFFFFFFF;
-
-	pci_bus_read_config_dword(pci_bus, PCI_DEVFN(new_slot->device, 0),
-					PCI_VENDOR_ID, &ID);
-
-	if (ID != 0xFFFFFFFF) {	  /*  device in slot */
-		pci_bus_read_config_byte(pci_bus, PCI_DEVFN(new_slot->device, 0),
-					0x0B, &class_code);
-
-		pci_bus_read_config_byte(pci_bus, PCI_DEVFN(new_slot->device, 0),
-					PCI_HEADER_TYPE, &header_type);
-
-		if (header_type & 0x80)	/* Multi-function device */
-			max_functions = 8;
-		else
-			max_functions = 1;
-
-		function = 0;
-
-		do {
-			if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {	  /* PCI-PCI Bridge */
-				/*  Recurse the subordinate bus */
-				pci_bus_read_config_byte(pci_bus,
-					PCI_DEVFN(new_slot->device, function), 
-					PCI_SECONDARY_BUS, &secondary_bus);
-
-				sub_bus = (int) secondary_bus;
-
-				/* Save the config headers for the secondary bus. */
-				rc = shpchp_save_config(ctrl, sub_bus, 0, 0);
-
-				if (rc)
-					return rc;
-
-			}	/* End of IF */
-
-			new_slot->status = 0;
-
-			for (cloop = 0; cloop < 0x20; cloop++) {
-				pci_bus_read_config_dword(pci_bus,
-					PCI_DEVFN(new_slot->device, function), 
-					cloop << 2,
-					(u32 *) &(new_slot->config_space [cloop]));
-			}
-
-			function++;
-
-			stop_it = 0;
-
-			/*  this loop skips to the next present function
-			 *  reading in the Class Code and the Header type.
-			 */
-
-			while ((function < max_functions) && (!stop_it)) {
-				pci_bus_read_config_dword(pci_bus,
-					PCI_DEVFN(new_slot->device, function),
-					PCI_VENDOR_ID, &ID);
-
-				if (ID == 0xFFFFFFFF) {	 /* nothing there. */
-					function++;
-				} else {  /* Something there */
-					pci_bus_read_config_byte(pci_bus,
-						PCI_DEVFN(new_slot->device, function),
-						0x0B, &class_code);
-
-					pci_bus_read_config_byte(pci_bus,
-						PCI_DEVFN(new_slot->device, function),
-						PCI_HEADER_TYPE, &header_type);
-
-					stop_it++;
-				}
-			}
-
-		} while (function < max_functions);
-	}			/* End of IF (device in slot?) */
-	else {
-		return 2;
-	}
-
-	return 0;
-}
-
