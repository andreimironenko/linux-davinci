From michael@ozlabs.org Thu Mar 22 03:53:46 2007
From: Michael Ellerman <michael@ellerman.id.au>
To: linux-pci@atrey.karlin.mff.cuni.cz
CC: Greg Kroah-Hartman <greg@kroah.com>,
	Eric W. Biederman <ebiederm@xmission.com>,
	David S. Miller <davem@davemloft.net>,
	Benjamin Herrenschmidt <benh@kernel.crashing.org>,
	Andrew Morton <akpm@osdl.org>,
	<daniel.e.wolstenholme@intel.com>
Date: Thu, 22 Mar 2007 21:51:39 +1100
Subject: MSI: Expand pci_msi_supported()
Message-Id: <20070322105340.53827DDF65@ozlabs.org>

pci_enable_msi() and pci_enable_msix() both search for the MSI/MSI-X
capability, we can fold this into pci_msi_supported() by passing the
type in.

Update the code to match the comment for pci_msi_supported(). That is
it returns 0 on success, and anything else indicates an error.

Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/msi.c |   19 ++++++++-----------
 1 file changed, 8 insertions(+), 11 deletions(-)

--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -433,12 +433,13 @@ static int msix_capability_init(struct p
 /**
  * pci_msi_supported - check whether MSI may be enabled on device
  * @dev: pointer to the pci_dev data structure of MSI device function
+ * @type: are we checking for MSI or MSI-X ?
  *
  * Look at global flags, the device itself, and its parent busses
  * to return 0 if MSI are supported for the device.
  **/
 static
-int pci_msi_supported(struct pci_dev * dev)
+int pci_msi_supported(struct pci_dev * dev, int type)
 {
 	struct pci_bus *bus;
 
@@ -456,6 +457,9 @@ int pci_msi_supported(struct pci_dev * d
 		if (bus->bus_flags & PCI_BUS_FLAGS_NO_MSI)
 			return -EINVAL;
 
+	if (!pci_find_capability(dev, type))
+		return -EINVAL;
+
 	return 0;
 }
 
@@ -471,13 +475,9 @@ int pci_msi_supported(struct pci_dev * d
  **/
 int pci_enable_msi(struct pci_dev* dev)
 {
-	int pos, status;
-
-	if (pci_msi_supported(dev) < 0)
-		return -EINVAL;
+	int status;
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
-	if (!pos)
+	if (pci_msi_supported(dev, PCI_CAP_ID_MSI))
 		return -EINVAL;
 
 	WARN_ON(!!dev->msi_enabled);
@@ -580,13 +580,10 @@ int pci_enable_msix(struct pci_dev* dev,
 	int i, j;
 	u16 control;
 
-	if (!entries || pci_msi_supported(dev) < 0)
+	if (!entries || pci_msi_supported(dev, PCI_CAP_ID_MSIX))
  		return -EINVAL;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
-	if (!pos)
- 		return -EINVAL;
-
 	pci_read_config_word(dev, msi_control_reg(pos), &control);
 	nr_entries = multi_msix_capable(control);
 	if (nvec > nr_entries)
