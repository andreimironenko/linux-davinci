From foo@baz Tue Apr  9 12:12:43 2002
Date: Tue, 09 Apr 2002 12:14:34 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: PCI: PCI "piggy" bus to allow multiple pci drivers to bind to a single device

Still under construction...

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/Makefile |    2 
 drivers/pci/piggy.c  |  194 +++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 196 insertions(+)

--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -45,6 +45,8 @@ ifndef CONFIG_X86
 obj-y += syscall.o
 endif
 
+obj-y += piggy.o
+
 ifeq ($(CONFIG_PCI_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
--- /dev/null
+++ b/drivers/pci/piggy.c
@@ -0,0 +1,194 @@
+/*
+ * piggy.c
+ *
+ * Copyright (C) 2007 Greg Kroah-Hartman <gregkh@suse.de>
+ * Copyright (C) 2007 Novell Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include "pci.h"
+
+struct piggy_ids {
+	struct list_head node;
+	const struct pci_device_id *id_table;
+	const struct piggy_driver *driver;
+};
+
+struct piggy_driver {
+	struct list_head node;
+	struct pci_driver *pci_drv;
+	struct device_driver driver;
+};
+#define to_piggy_driver(n) container_of(struct piggy_driver, driver)
+
+struct piggy_device {
+	struct list_head node;		/* node in list of all piggy devices */
+	struct pci_dev *pdev;		/* backing pci device */
+	struct device dev;		/* Generic device interface */
+};
+#define to_piggy_dev(n) container_of(struct piggy_device, dev)
+
+
+static struct list_head piggy_ids;
+static struct list_head piggy_devices;
+static struct list_head piggy_drivers;
+static struct mutex piggy_drivers_lock;
+
+/* we want the option to bind to all pci devices */
+static struct pci_device_id all_ids[] = {
+	{ PCI_DEVICE(PCI_ANY_ID, PCI_ANY_ID) },
+	{ },
+};
+
+/* returns the number of piggy drivers that will match this id */
+static int match_pci_ids(struct pci_dev *dev)
+{
+	struct piggy_driver *pig_drv;
+	const struct pci_device_id *pci_id;
+	int num_match = 0;
+
+	mutex_lock(&piggy_drivers_lock);
+	list_for_each_entry(pig_drv, &piggy_drivers, node) {
+		pci_id = pci_match_device(pig_drv->pci_drv, dev);
+		if (pci_id)
+			++num_match;
+	}
+	mutex_unlock(&piggy_drivers_lock);
+
+	return num_match;
+}
+
+
+static int pci_piggy_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int num_devices;
+
+	/* if we don't match any devices at all, then we don't need to
+	 * bind to the device */
+	num_devices = match_pci_ids(dev);
+	if (!num_devices)
+		return -ENODEV;
+
+	/* create a number of piggy devices to bind to this pci device */
+
+	return 0;
+}
+
+static void pci_piggy_remove(struct pci_dev *dev)
+{
+}
+
+static struct pci_driver pci_piggy_driver = {
+	.name =		"piggy_bridge",
+	.probe =	pci_piggy_probe,
+	.remove = 	pci_piggy_remove,
+	.id_table =	all_ids,
+};
+
+static int piggy_device_match(struct device *dev, struct device_driver *drv)
+{
+	return 0;
+}
+
+static int piggy_device_probe(struct device *dev)
+{
+	return 0;
+}
+static int piggy_device_remove(struct device *dev)
+{
+	return 0;
+}
+
+static struct bus_type piggy_bus_type = {
+	.name =		"pci-piggy",
+	.match =	piggy_device_match,
+	.probe =	piggy_device_probe,
+	.remove =	piggy_device_remove,
+};
+
+
+
+
+int pci_piggy_driver_register(struct pci_driver *pci_drv, struct module *owner,
+			      const char *mod_name)
+{
+	struct piggy_driver *pig_drv;
+
+	/* FIXME create a pci driver here too?  People are going to get
+	 * confused...*/
+
+	pig_drv = kzalloc(sizeof(*pig_drv), GFP_KERNEL);
+	if (!pig_drv)
+		return -ENOMEM;
+	INIT_LIST_HEAD(&pig_drv->node);
+	pig_drv->pci_drv = pci_drv;
+
+	pig_drv->driver.name = pci_drv->name;
+	pig_drv->driver.bus = &piggy_bus_type;
+	pig_drv->driver.owner = owner;
+	pig_drv->driver.mod_name = mod_name;
+
+	mutex_lock(&piggy_drivers_lock);
+	list_add_tail(&piggy_drivers, &pig_drv->node);
+	mutex_unlock(&piggy_drivers_lock);
+
+	return driver_register(&pig_drv->driver);
+}
+
+
+void pci_piggy_driver_deregister(struct pci_driver *pci_drv)
+{
+	struct piggy_driver *match;
+	struct piggy_driver *pig_drv = NULL;
+
+	/* walk the list and find me the driver with the same name */
+	mutex_lock(&piggy_drivers_lock);
+	list_for_each_entry(match, &piggy_drivers, node) {
+		if (strcmp(match->driver.name, pci_drv->name) == 0)
+			pig_drv = match;
+			break;
+	}
+	mutex_unlock(&piggy_drivers_lock);
+
+	if (!pig_drv) {
+		printk(KERN_ERR "PCI: piggy driver not found for pci driver "
+				"'%s'\n", pci_drv->name);
+		return;
+	}
+
+	/* this is the one */
+	list_del(&pig_drv->node);
+	driver_unregister(&pig_drv->driver);
+	kfree(pig_drv);
+	/* FIXME have to do some device lifecycle here probably...*/
+}
+
+
+static int __init pci_piggy_init(void)
+{
+	int result;
+
+	INIT_LIST_HEAD(&piggy_ids);
+	INIT_LIST_HEAD(&piggy_devices);
+	INIT_LIST_HEAD(&piggy_drivers);
+
+	mutex_init(&piggy_drivers_lock);
+
+	result = bus_register(&piggy_bus_type);
+	if (result) {
+		printk(KERN_ERR "PCI: can not register piggy bus\n");
+		return result;
+	}
+
+	return 0;
+//	return pci_register_driver(&pci_piggy_driver);
+}
+
+postcore_initcall(pci_piggy_init);
+
