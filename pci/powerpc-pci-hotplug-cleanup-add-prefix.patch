From linas@austin.ibm.com Thu Jan 12 16:31:04 2006
Date: Thu, 12 Jan 2006 18:31:01 -0600
From: linas@austin.ibm.com
To: Greg KH <greg@kroah.com>, akpm@osdl.org
Cc: Paul Mackerras <paulus@samba.org>
Subject: [PATCH 7/9] powerpc/PCI hotplug: cleanup: add prefix
Message-ID: <20060113003101.GE26221@austin.ibm.com>
Content-Disposition: inline



Minor cleanup. Add the prefix rpaphp_* to several generic-sounding routines.
Remove rpaphp_remove_slot(), which is a one-liner. 

Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
Acked-by: John Rose <johnrose@austin.ibm.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/hotplug/rpadlpar_core.c |    4 ++--
 drivers/pci/hotplug/rpaphp.h        |    6 +++---
 drivers/pci/hotplug/rpaphp_core.c   |   14 +++++---------
 drivers/pci/hotplug/rpaphp_pci.c    |    4 ++--
 drivers/pci/hotplug/rpaphp_slot.c   |   16 ++++++++--------
 5 files changed, 20 insertions(+), 24 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/rpaphp_core.c
+++ gregkh-2.6/drivers/pci/hotplug/rpaphp_core.c
@@ -196,11 +196,6 @@ static int get_max_bus_speed(struct hotp
 	return 0;
 }
 
-int rpaphp_remove_slot(struct slot *slot)
-{
-	return deregister_slot(slot);
-}
-
 static int get_children_props(struct device_node *dn, int **drc_indexes,
 		int **drc_names, int **drc_types, int **drc_power_domains)
 {
@@ -307,13 +302,15 @@ static int is_php_dn(struct device_node 
 	return 0;
 }
 
-/****************************************************************
+/**
+ * rpaphp_add_slot -- add hotplug or dlpar slot
+ *
  *	rpaphp not only registers PCI hotplug slots(HOTPLUG), 
  *	but also logical DR slots(EMBEDDED).
  *	HOTPLUG slot: An adapter can be physically added/removed. 
  *	EMBEDDED slot: An adapter can be logically removed/added
  *		  from/to a partition with the slot.
- ***************************************************************/
+ */
 int rpaphp_add_slot(struct device_node *dn)
 {
 	struct slot *slot;
@@ -344,7 +341,7 @@ int rpaphp_add_slot(struct device_node *
 			dbg("Found drc-index:0x%x drc-name:%s drc-type:%s\n",
 					indexes[i + 1], name, type);
 
-			retval = register_pci_slot(slot);
+			retval = rpaphp_register_pci_slot(slot);
 		}
 	}
 exit:
@@ -462,6 +459,5 @@ module_init(rpaphp_init);
 module_exit(rpaphp_exit);
 
 EXPORT_SYMBOL_GPL(rpaphp_add_slot);
-EXPORT_SYMBOL_GPL(rpaphp_remove_slot);
 EXPORT_SYMBOL_GPL(rpaphp_slot_head);
 EXPORT_SYMBOL_GPL(rpaphp_get_drc_props);
--- gregkh-2.6.orig/drivers/pci/hotplug/rpaphp_pci.c
+++ gregkh-2.6/drivers/pci/hotplug/rpaphp_pci.c
@@ -199,7 +199,7 @@ exit_rc:
 	return -EINVAL;
 }
 
-int register_pci_slot(struct slot *slot)
+int rpaphp_register_pci_slot(struct slot *slot)
 {
 	int rc = -EINVAL;
 
@@ -207,7 +207,7 @@ int register_pci_slot(struct slot *slot)
 		goto exit_rc;
 	if (setup_pci_slot(slot))
 		goto exit_rc;
-	rc = register_slot(slot);
+	rc = rpaphp_register_slot(slot);
 exit_rc:
 	return rc;
 }
--- gregkh-2.6.orig/drivers/pci/hotplug/rpadlpar_core.c
+++ gregkh-2.6/drivers/pci/hotplug/rpadlpar_core.c
@@ -227,7 +227,7 @@ static int dlpar_remove_phb(char *drc_na
 	slot = find_slot(dn);
 	if (slot) {
 		/* Remove hotplug slot */
-		if (rpaphp_remove_slot(slot)) {
+		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
 				__FUNCTION__, drc_name);
@@ -373,7 +373,7 @@ int dlpar_remove_pci_slot(char *drc_name
 	slot = find_slot(dn);
 	if (slot) {
 		/* Remove hotplug slot */
-		if (rpaphp_remove_slot(slot)) {
+		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
 				__FUNCTION__, drc_name);
--- gregkh-2.6.orig/drivers/pci/hotplug/rpaphp_slot.c
+++ gregkh-2.6/drivers/pci/hotplug/rpaphp_slot.c
@@ -35,16 +35,16 @@
 
 static ssize_t location_read_file (struct hotplug_slot *php_slot, char *buf)
 {
-        char *value;
-        int retval = -ENOENT;
+	char *value;
+	int retval = -ENOENT;
 	struct slot *slot = (struct slot *)php_slot->private;
 
 	if (!slot)
 		return retval;
 
-        value = slot->location;
-        retval = sprintf (buf, "%s\n", value);
-        return retval;
+	value = slot->location;
+	retval = sprintf (buf, "%s\n", value);
+	return retval;
 }
 
 static struct hotplug_slot_attribute hotplug_slot_attr_location = {
@@ -137,7 +137,7 @@ static int is_registered(struct slot *sl
 	return 0;
 }
 
-int deregister_slot(struct slot *slot)
+int rpaphp_deregister_slot(struct slot *slot)
 {
 	int retval = 0;
 	struct hotplug_slot *php_slot = slot->hotplug_slot;
@@ -160,7 +160,7 @@ int deregister_slot(struct slot *slot)
 	return retval;
 }
 
-int register_slot(struct slot *slot)
+int rpaphp_register_slot(struct slot *slot)
 {
 	int retval;
 
@@ -169,7 +169,7 @@ int register_slot(struct slot *slot)
 		slot->power_domain, slot->type);
 	/* should not try to register the same slot twice */
 	if (is_registered(slot)) { /* should't be here */
-		err("register_slot: slot[%s] is already registered\n", slot->name);
+		err("rpaphp_register_slot: slot[%s] is already registered\n", slot->name);
 		rpaphp_release_slot(slot->hotplug_slot);
 		return -EAGAIN;
 	}	
--- gregkh-2.6.orig/drivers/pci/hotplug/rpaphp.h
+++ gregkh-2.6/drivers/pci/hotplug/rpaphp.h
@@ -89,7 +89,7 @@ extern int num_slots;
 
 /* rpaphp_pci.c */
 extern int rpaphp_enable_pci_slot(struct slot *slot);
-extern int register_pci_slot(struct slot *slot);
+extern int rpaphp_register_pci_slot(struct slot *slot);
 extern int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value);
 extern int rpaphp_get_sensor_state(struct slot *slot, int *state);
 
@@ -102,8 +102,8 @@ extern int rpaphp_get_drc_props(struct d
 /* rpaphp_slot.c */
 extern void dealloc_slot_struct(struct slot *slot);
 extern struct slot *alloc_slot_struct(struct device_node *dn, int drc_index, char *drc_name, int power_domain);
-extern int register_slot(struct slot *slot);
-extern int deregister_slot(struct slot *slot);
+extern int rpaphp_register_slot(struct slot *slot);
+extern int rpaphp_deregister_slot(struct slot *slot);
 extern int rpaphp_get_power_status(struct slot *slot, u8 * value);
 extern int rpaphp_set_attention_status(struct slot *slot, u8 status);
 	
