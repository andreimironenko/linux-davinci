From prarit@sgi.com Tue Apr  4 06:26:54 2006
Date: Tue, 4 Apr 2006 09:26:46 -0400
From: Prarit Bhargava <prarit@sgi.com>
To: <edwardsg@sgi.com>
Cc: Prarit Bhargava <prarit@sgi.com>
Message-Id: <20060404132641.10912.44536.sendpatchset@prarit.boston.redhat.com>
Subject: PCI Hotplug: Tollhouse HP: SGI hotplug driver changes

SGI hotplug driver changes required to support Tollhouse system PCI
hotplug, and implements the PRF_HOTPLUG_SUPPORT feature bit.

Signed-off-by: Prarit Bhargava <prarit@sgi.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/hotplug/sgi_hotplug.c |   42 +++++++++++++++++++-------------------
 1 file changed, 21 insertions(+), 21 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/sgi_hotplug.c
+++ gregkh-2.6/drivers/pci/hotplug/sgi_hotplug.c
@@ -18,11 +18,13 @@
 #include <linux/mutex.h>
 
 #include <asm/sn/addrs.h>
+#include <asm/sn/geo.h>
 #include <asm/sn/l1.h>
 #include <asm/sn/module.h>
 #include <asm/sn/pcibr_provider.h>
 #include <asm/sn/pcibus_provider_defs.h>
 #include <asm/sn/pcidev.h>
+#include <asm/sn/sn_feature_sets.h>
 #include <asm/sn/sn_sal.h>
 #include <asm/sn/types.h>
 
@@ -102,8 +104,7 @@ static struct hotplug_slot_attribute sn_
 static int sn_pci_slot_valid(struct pci_bus *pci_bus, int device)
 {
 	struct pcibus_info *pcibus_info;
-	int bricktype;
-	int bus_num;
+	u16 busnum, segment, ioboard_type;
 
 	pcibus_info = SN_PCIBUS_BUSSOFT_INFO(pci_bus);
 
@@ -111,12 +112,14 @@ static int sn_pci_slot_valid(struct pci_
 	if (!(pcibus_info->pbi_valid_devices & (1 << device)))
 		return -EPERM;
 
-	bricktype = MODULE_GET_BTYPE(pcibus_info->pbi_moduleid);
-	bus_num = pcibus_info->pbi_buscommon.bs_persist_busnum & 0xf;
+	ioboard_type = sn_ioboard_to_pci_bus(pci_bus);
+	busnum = pcibus_info->pbi_buscommon.bs_persist_busnum;
+	segment = pci_domain_nr(pci_bus) & 0xf;
 
 	/* Do not allow hotplug operations on base I/O cards */
-	if ((bricktype == L1_BRICKTYPE_IX ||  bricktype == L1_BRICKTYPE_IA) &&
-	    (bus_num == 1 && device != 1))
+	if ((ioboard_type == L1_BRICKTYPE_IX ||
+	     ioboard_type == L1_BRICKTYPE_IA) &&
+	    (segment == 1 && busnum == 0 && device != 1))
 		return -EPERM;
 
 	return 1;
@@ -125,23 +128,23 @@ static int sn_pci_slot_valid(struct pci_
 static int sn_pci_bus_valid(struct pci_bus *pci_bus)
 {
 	struct pcibus_info *pcibus_info;
-	int asic_type;
-	int bricktype;
-
-	pcibus_info = SN_PCIBUS_BUSSOFT_INFO(pci_bus);
+	u32 asic_type;
+	u16 ioboard_type;
 
 	/* Don't register slots hanging off the TIOCA bus */
+	pcibus_info = SN_PCIBUS_BUSSOFT_INFO(pci_bus);
 	asic_type = pcibus_info->pbi_buscommon.bs_asic_type;
 	if (asic_type == PCIIO_ASIC_TYPE_TIOCA)
 		return -EPERM;
 
 	/* Only register slots in I/O Bricks that support hotplug */
-	bricktype = MODULE_GET_BTYPE(pcibus_info->pbi_moduleid);
-	switch (bricktype) {
+	ioboard_type = sn_ioboard_to_pci_bus(pci_bus);
+	switch (ioboard_type) {
 		case L1_BRICKTYPE_IX:
 		case L1_BRICKTYPE_PX:
 		case L1_BRICKTYPE_IA:
 		case L1_BRICKTYPE_PA:
+		case L1_BOARDTYPE_PCIX3SLOT:
 			return 1;
 			break;
 		default:
@@ -175,14 +178,11 @@ static int sn_hp_slot_private_alloc(stru
 	slot->pci_bus = pci_bus;
 	sprintf(bss_hotplug_slot->name, "%04x:%02x:%02x",
 		pci_domain_nr(pci_bus),
-		((int)pcibus_info->pbi_buscommon.bs_persist_busnum) & 0xf,
+		((u16)pcibus_info->pbi_buscommon.bs_persist_busnum),
 		device + 1);
-	sprintf(slot->physical_path, "module_%c%c%c%c%.2d",
-		'0'+RACK_GET_CLASS(MODULE_GET_RACK(pcibus_info->pbi_moduleid)),
-		'0'+RACK_GET_GROUP(MODULE_GET_RACK(pcibus_info->pbi_moduleid)),
-		'0'+RACK_GET_NUM(MODULE_GET_RACK(pcibus_info->pbi_moduleid)),
-		MODULE_GET_BTCHAR(pcibus_info->pbi_moduleid),
-		MODULE_GET_BPOS(pcibus_info->pbi_moduleid));
+
+	sn_generate_path(pci_bus, slot->physical_path);
+
 	slot->hotplug_slot = bss_hotplug_slot;
 	list_add(&slot->hp_list, &sn_hp_list);
 
@@ -553,8 +553,8 @@ static int sn_pci_hotplug_init(void)
 	int rc;
 	int registered = 0;
 
-	if (sn_sal_rev() < SGI_HOTPLUG_PROM_REV) {
-		printk(KERN_ERR "%s: PROM version must be greater than 4.30\n",
+	if (!sn_prom_feature_available(PRF_HOTPLUG_SUPPORT)) {
+		printk(KERN_ERR "%s: PROM version does not support hotplug.\n",
 		       __FUNCTION__);
 		return -EPERM;
 	}
