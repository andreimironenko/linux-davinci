From kristen.c.accardi@intel.com Mon Oct 30 12:09:19 2006
Date: Mon, 30 Oct 2006 13:08:12 -0800
From: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
To: gregkh@suse.de
Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>, Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Subject: [patch 3/3] pci: clear osc support flags if no _OSC method
Message-Id: <20061030130812.2aa89ced.kristen.c.accardi@intel.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII

From: Kristen Carlson Accardi <kristen.c.accardi@intel.com>

So it looks like pci aer code will call pci_osc_support_set to tell the
firmware about  OSC_EXT_PCI_CONFIG_SUPPORT flag.  that causes
ctrlset_buf[OSC_SUPPORT_TYPE] to evaluate to true when pciehp calls
pci_osc_control_set() is called (to attempt to use OSC to gain native
pcie control from firmware), regardless of whether or not _OSC was
actually successfully executed.  That causes this section of code:
 if (ctrlset_buf[OSC_SUPPORT_TYPE] &&
                ((global_ctrlsets & ctrlset) != ctrlset)) {
                return AE_SUPPORT;
        }
to be hit.

This patch will reset the OSC_SUPPORT_TYPE field if _OSC fails, and then
would allow pciehp to go ahead and try to run _OSC again.

Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/pci-acpi.c |   10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

--- gregkh-2.6.orig/drivers/pci/pci-acpi.c
+++ gregkh-2.6/drivers/pci/pci-acpi.c
@@ -36,6 +36,7 @@ acpi_query_osc (
 	struct acpi_buffer	output = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object 	*out_obj;
 	u32			osc_dw0;
+	acpi_status *ret_status = (acpi_status *)retval;
 
 	
 	/* Setting up input parameters */
@@ -56,6 +57,7 @@ acpi_query_osc (
 	if (ACPI_FAILURE (status)) {
 		printk(KERN_DEBUG  
 			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
+		*ret_status = status;
 		return status;
 	}
 	out_obj = output.pointer;
@@ -90,6 +92,7 @@ acpi_query_osc (
 
 query_osc_out:
 	kfree(output.pointer);
+	*ret_status = status;
 	return status;
 }
 
@@ -166,6 +169,7 @@ run_osc_out:
 acpi_status pci_osc_support_set(u32 flags)
 {
 	u32 temp;
+	acpi_status retval;
 
 	if (!(flags & OSC_SUPPORT_MASKS)) {
 		return AE_TYPE;
@@ -179,9 +183,13 @@ acpi_status pci_osc_support_set(u32 flag
 	acpi_get_devices ( PCI_ROOT_HID_STRING,
 			acpi_query_osc,
 			ctrlset_buf,
-			NULL );
+			(void **) &retval );
 	ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
 	ctrlset_buf[OSC_CONTROL_TYPE] = temp;
+	if (ACPI_FAILURE(retval)) {
+		/* no osc support at all */
+		ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
+	}
 	return AE_OK;
 }
 EXPORT_SYMBOL(pci_osc_support_set);
