From kristen.c.accardi@intel.com Thu Dec 21 17:01:38 2006
From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
To: akpm@osdl.org
Cc: greg@kroah.com, Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Subject: [PATCH 9/10] pciehp: fix wait command completion
Date: Thu, 21 Dec 2006 17:01:10 -0800
Message-Id: <11667492762909-git-send-email-kristen.c.accardi@intel.com>

From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>

This patch fixes this problem that pciehp driver will sleep
unnecessarily long when waiting for command completion. With this
patch, modprobe pciehp driver becomes very faster as follows for
instance.

  o Without this patch
    # time /sbin/modprobe pciehp

    real    0m4.976s
    user    0m0.000s
    sys     0m0.004s

  o With this patch
    # time /sbin/modprobe pciehp

    real    0m0.640s
    user    0m0.000s
    sys     0m0.004s

Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/hotplug/pciehp.h     |    1 +
 drivers/pci/hotplug/pciehp_hpc.c |   27 +++++++++++++++------------
 2 files changed, 16 insertions(+), 12 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp.h
+++ gregkh-2.6/drivers/pci/hotplug/pciehp.h
@@ -100,6 +100,7 @@ struct controller {
 	u16 vendor_id;
 	u8 cap_base;
 	struct timer_list poll_timer;
+	volatile int cmd_busy;
 };
 
 #define INT_BUTTON_IGNORE		0
--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp_hpc.c
+++ gregkh-2.6/drivers/pci/hotplug/pciehp_hpc.c
@@ -251,20 +251,21 @@ static void start_int_poll_timer(struct 
 
 static inline int pcie_wait_cmd(struct controller *ctrl)
 {
-	DECLARE_WAITQUEUE(wait, current);
-
-	add_wait_queue(&ctrl->queue, &wait);
-	if (!pciehp_poll_mode)
-		/* Sleep for up to 1 second */
-		msleep_interruptible(1000);
-	else
-		msleep_interruptible(2500);
+	int retval = 0;
+	unsigned int msecs = pciehp_poll_mode ? 2500 : 1000;
+	unsigned long timeout = msecs_to_jiffies(msecs);
+	int rc;
 
-	remove_wait_queue(&ctrl->queue, &wait);
-	if (signal_pending(current))
-		return -EINTR;
+	rc = wait_event_interruptible_timeout(ctrl->queue,
+					      !ctrl->cmd_busy, timeout);
+	if (!rc)
+		dbg("Command not completed in 1000 msec\n");
+	else if (rc < 0) {
+		retval = -EINTR;
+		info("Command was interrupted by a signal\n");
+	}
 
-	return 0;
+	return retval;
 }
 
 static int pcie_write_cmd(struct slot *slot, u16 cmd)
@@ -291,6 +292,7 @@ static int pcie_write_cmd(struct slot *s
 		    __FUNCTION__);
 	}
 
+	ctrl->cmd_busy = 1;
 	retval = pciehp_writew(ctrl, SLOTCTRL, (cmd | CMD_CMPL_INTR_ENABLE));
 	if (retval) {
 		err("%s: Cannot write to SLOTCTRL register\n", __FUNCTION__);
@@ -773,6 +775,7 @@ static irqreturn_t pcie_isr(int irq, voi
 		/* 
 		 * Command Complete Interrupt Pending 
 		 */
+		ctrl->cmd_busy = 0;
 		wake_up_interruptible(&ctrl->queue);
 	}
 
