From kaneshige.kenji@jp.fujitsu.com Mon May  1 19:12:18 2006
Message-ID: <4456BF66.6090200@jp.fujitsu.com>
Date: Tue, 02 May 2006 11:09:42 +0900
From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
To: Greg KH <gregkh@suse.de>, Kristen Accardi <kristen.c.accardi@intel.com>
Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Subject: SHPC: Cleanup SHPC Logical Slot Register access

This patch cleans up the code to access slot logical registers. This
patch has no functional changes.

Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Cc: Kristen Accardi <kristen.c.accardi@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/pci/hotplug/shpchp_hpc.c |   31 ++++++++++++++++++-------------
 1 file changed, 18 insertions(+), 13 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp_hpc.c
+++ gregkh-2.6/drivers/pci/hotplug/shpchp_hpc.c
@@ -90,6 +90,11 @@
 #define	MRLSENSOR		0x40000000
 #define ATTN_BUTTON		0x80000000
 
+/*
+ * Logical Slot Register definitions
+ */
+#define SLOT_REG(i)		(SLOT1 + (4 * i))
+
 /* Slot Status Field Definitions */
 /* Slot State */
 #define PWR_ONLY		0x0001
@@ -433,7 +438,7 @@ static int hpc_get_attention_status(stru
 		return -1;
 	}
 
-	slot_reg = shpc_readl(ctrl, SLOT1 + 4*(slot->hp_slot));
+	slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));
 	slot_status = (u16) slot_reg;
 	atten_led_state = (slot_status & 0x0030) >> 4;
 
@@ -474,7 +479,7 @@ static int hpc_get_power_status(struct s
 		return -1;
 	}
 
-	slot_reg = shpc_readl(ctrl, SLOT1 + 4*(slot->hp_slot));
+	slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));
 	slot_status = (u16) slot_reg;
 	slot_state = (slot_status & 0x0003);
 
@@ -514,7 +519,7 @@ static int hpc_get_latch_status(struct s
 		return -1;
 	}
 
-	slot_reg = shpc_readl(ctrl, SLOT1 + 4*(slot->hp_slot));
+	slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));
 	slot_status = (u16)slot_reg;
 
 	*status = ((slot_status & 0x0100) == 0) ? 0 : 1;   /* 0 -> close; 1 -> open */
@@ -538,7 +543,7 @@ static int hpc_get_adapter_status(struct
 		return -1;
 	}
 
-	slot_reg = shpc_readl(ctrl, SLOT1 + 4*(slot->hp_slot));
+	slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));
 	slot_status = (u16)slot_reg;
 	card_state = (u8)((slot_status & 0x0C00) >> 10);
 	*status = (card_state != 0x3) ? 1 : 0;
@@ -568,7 +573,7 @@ static int hpc_get_adapter_speed(struct 
 {
 	int retval = 0;
 	struct controller *ctrl = slot->ctrl;
-	u32 slot_reg = shpc_readl(ctrl, SLOT1 + 4 * slot->hp_slot);
+	u32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));
 	u8 pcix_cap = (slot_reg >> 12) & 7;
 	u8 m66_cap  = (slot_reg >> 9) & 1;
 
@@ -648,7 +653,7 @@ static int hpc_query_power_fault(struct 
 		return -1;
 	}
 
-	slot_reg = shpc_readl(ctrl, SLOT1 + 4*(slot->hp_slot));
+	slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));
 	slot_status = (u16) slot_reg;
 	pwr_fault_state = (slot_status & 0x0040) >> 7;
 	status = (pwr_fault_state == 1) ? 0 : 1;
@@ -805,7 +810,7 @@ static void hpc_release_ctlr(struct cont
 	 * Mask all slot event interrupts
 	 */
 	for (i = 0; i < ctrl->num_slots; i++)
-		shpc_writel(ctrl, SLOT1 + (4 * i), 0xffff3fff);
+		shpc_writel(ctrl, SLOT_REG(i), 0xffff3fff);
 
 	cleanup_slots(ctrl);
 
@@ -1072,7 +1077,7 @@ static irqreturn_t shpc_isr(int IRQ, voi
 	for (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) { 
 	/* To find out which slot has interrupt pending */
 		if ((intr_loc >> hp_slot) & 0x01) {
-			temp_dword = shpc_readl(ctrl, SLOT1 + (4*hp_slot));
+			temp_dword = shpc_readl(ctrl, SLOT_REG(hp_slot));
 			dbg("%s: Slot %x with intr, slot register = %x\n",
 				__FUNCTION__, hp_slot, temp_dword);
 			temp_byte = (temp_dword >> 16) & 0xFF;
@@ -1091,7 +1096,7 @@ static irqreturn_t shpc_isr(int IRQ, voi
 			
 			/* Clear all slot events */
 			temp_dword = 0xe01f3fff;
-			shpc_writel(ctrl, SLOT1 + (4*hp_slot), temp_dword);
+			shpc_writel(ctrl, SLOT_REG(hp_slot), temp_dword);
 
 			intr_loc2 = shpc_readl(ctrl, INTR_LOC);
 			dbg("%s: intr_loc2 = %x\n",__FUNCTION__, intr_loc2); 
@@ -1379,11 +1384,11 @@ int shpc_init(struct controller * ctrl, 
 	 * Slot SERR-INT Mask & clear all the existing event if any
 	 */
 	for (hp_slot = 0; hp_slot < php_ctlr->num_slots; hp_slot++) {
-		slot_reg = shpc_readl(ctrl, SLOT1 + 4*hp_slot );
+		slot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));
 		dbg("%s: Default Logical Slot Register %d value %x\n", __FUNCTION__,
 			hp_slot, slot_reg);
 		tempdword = 0xffff3fff;  
-		shpc_writel(ctrl, SLOT1 + (4*hp_slot), tempdword);
+		shpc_writel(ctrl, SLOT_REG(hp_slot), tempdword);
 	}
 	
 	if (shpchp_poll_mode)  {/* Install interrupt polling code */
@@ -1430,11 +1435,11 @@ int shpc_init(struct controller * ctrl, 
 	ctlr_seq_num++;
 
 	for (hp_slot = 0; hp_slot < php_ctlr->num_slots; hp_slot++) {
-		slot_reg = shpc_readl(ctrl, SLOT1 + 4*hp_slot );
+		slot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));
 		dbg("%s: Default Logical Slot Register %d value %x\n", __FUNCTION__,
 			hp_slot, slot_reg);
 		tempdword = 0xe01f3fff;  
-		shpc_writel(ctrl, SLOT1 + (4*hp_slot), tempdword);
+		shpc_writel(ctrl, SLOT_REG(hp_slot), tempdword);
 	}
 	if (!shpchp_poll_mode) {
 		/* Unmask all general input interrupts and SERR */
