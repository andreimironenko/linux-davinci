From pcihpd-discuss-admin@lists.sourceforge.net Mon May  1 18:58:14 2006
Message-ID: <4456BBEA.2000005@jp.fujitsu.com>
From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
To: gregkh@suse.de, kristen.c.accardi@intel.com
Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Subject: acpi_pcihp: Fix programming _HPP values
Date: Tue, 02 May 2006 10:54:50 +0900

This patch fixes the problem that hotplug parameters are not programed
when PCI cards are hot-added by ACPIPHP, SHPCHP and PCIEHP driver. The
pci_dev structure being hot-added is not bound to ACPI handle, so we
need to trace PCI bus tree to find ACPI handle.

Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Cc: Kristen Accardi <kristen.c.accardi@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/pci/hotplug/acpi_pcihp.c   |   34 ++++++++++++++++++++++++----------
 drivers/pci/hotplug/acpiphp_glue.c |    3 ++-
 drivers/pci/hotplug/pci_hotplug.h  |    2 +-
 drivers/pci/hotplug/pciehp.h       |    2 +-
 drivers/pci/hotplug/shpchp.h       |    2 +-
 5 files changed, 29 insertions(+), 14 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/acpi_pcihp.c
+++ gregkh-2.6/drivers/pci/hotplug/acpi_pcihp.c
@@ -145,14 +145,27 @@ EXPORT_SYMBOL_GPL(acpi_run_oshp);
 
 /* acpi_get_hp_params_from_firmware
  *
- * @dev - the pci_dev of the newly added device
+ * @bus - the pci_bus of the bus on which the device is newly added
  * @hpp - allocated by the caller
  */
-acpi_status acpi_get_hp_params_from_firmware(struct pci_dev *dev,
+acpi_status acpi_get_hp_params_from_firmware(struct pci_bus *bus,
 		struct hotplug_params *hpp)
 {
 	acpi_status status = AE_NOT_FOUND;
-	struct pci_dev *pdev = dev;
+	acpi_handle handle, phandle;
+	struct pci_bus *pbus = bus;
+	struct pci_dev *pdev;
+
+	do {
+		pdev = pbus->self;
+		if (!pdev) {
+			handle = acpi_get_pci_rootbridge_handle(
+				pci_domain_nr(pbus), pbus->number);
+			break;
+		}
+		handle = DEVICE_ACPI_HANDLE(&(pdev->dev));
+		pbus = pbus->parent;
+	} while (!handle);
 
 	/*
 	 * _HPP settings apply to all child buses, until another _HPP is
@@ -160,15 +173,16 @@ acpi_status acpi_get_hp_params_from_firm
 	 * look for it in the parent device scope since that would apply to
 	 * this pci dev. If we don't find any _HPP, use hardcoded defaults
 	 */
-	while (pdev && (ACPI_FAILURE(status))) {
-		acpi_handle handle = DEVICE_ACPI_HANDLE(&(pdev->dev));
-		if (!handle)
-			break;
+	while (handle) {
 		status = acpi_run_hpp(handle, hpp);
-		if (!(pdev->bus->parent))
+		if (ACPI_SUCCESS(status))
+			break;
+		if (acpi_root_bridge(handle))
+			break;
+		status = acpi_get_parent(handle, &phandle);
+		if (ACPI_FAILURE(status))
 			break;
-		/* Check if a parent object supports _HPP */
-		pdev = pdev->bus->parent->self;
+		handle = phandle;
 	}
 	return status;
 }
--- gregkh-2.6.orig/drivers/pci/hotplug/acpiphp_glue.c
+++ gregkh-2.6/drivers/pci/hotplug/acpiphp_glue.c
@@ -286,7 +286,7 @@ static void decode_hpp(struct acpiphp_br
 {
 	acpi_status status;
 
-	status = acpi_get_hp_params_from_firmware(bridge->pci_dev, &bridge->hpp);
+	status = acpi_get_hp_params_from_firmware(bridge->pci_bus, &bridge->hpp);
 	if (ACPI_FAILURE(status)) {
 		/* use default numbers */
 		bridge->hpp.cache_line_size = 0x10;
@@ -1250,6 +1250,7 @@ static void acpiphp_set_hpp_values(acpi_
 
 	memset(&bridge, 0, sizeof(bridge));
 	bridge.handle = handle;
+	bridge.pci_bus = bus;
 	bridge.pci_dev = bus->self;
 	decode_hpp(&bridge);
 	list_for_each_entry(dev, &bus->devices, bus_list)
--- gregkh-2.6.orig/drivers/pci/hotplug/pci_hotplug.h
+++ gregkh-2.6/drivers/pci/hotplug/pci_hotplug.h
@@ -188,7 +188,7 @@ struct hotplug_params {
 #include <acpi/acpi_bus.h>
 #include <acpi/actypes.h>
 extern acpi_status acpi_run_oshp(acpi_handle handle);
-extern acpi_status acpi_get_hp_params_from_firmware(struct pci_dev *dev,
+extern acpi_status acpi_get_hp_params_from_firmware(struct pci_bus *bus,
 				struct hotplug_params *hpp);
 int acpi_root_bridge(acpi_handle handle);
 #endif
--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp.h
+++ gregkh-2.6/drivers/pci/hotplug/pciehp.h
@@ -284,7 +284,7 @@ struct hpc_ops {
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 			struct hotplug_params *hpp)
 {
-	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev, hpp)))
+	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev->bus, hpp)))
 		return -ENODEV;
 	return 0;
 }
--- gregkh-2.6.orig/drivers/pci/hotplug/shpchp.h
+++ gregkh-2.6/drivers/pci/hotplug/shpchp.h
@@ -196,7 +196,7 @@ extern void	queue_pushbutton_work(void *
 static inline int get_hp_params_from_firmware(struct pci_dev *dev,
 			struct hotplug_params *hpp)
 {
-	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev, hpp)))
+	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev->bus, hpp)))
 			return -ENODEV;
 	return 0;
 }
