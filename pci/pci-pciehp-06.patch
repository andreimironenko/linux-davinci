From owner-linux-pci@atrey.karlin.mff.cuni.cz Mon Oct 31 16:31:09 2005
Message-Id: <20051101002124.233201779@csdlinux-2.jf.intel.com>
Date: Mon, 31 Oct 2005 16:20:11 -0800
From: rajesh.shah@intel.com
To: kristen.c.accardi@intel.com, gregkh@suse.de
Cc: akpm@osdl.org, rajesh.shah@intel.com
Subject: [patch 6/8] pciehp: request control of each hotplug controller individually
Content-Disposition: inline; filename=acpi-make-osc-call-per-handle

This patch tweaks the way pciehp requests control of the hotplug
hardware from BIOS. It now tries to invoke the ACPI _OSC method
for a specific hotplug controller only, rather than walking the
entire acpi namespace invoking all possible _OSC methods under
all host bridges. This allows us to gain control of each hotplug
controller individually, even if BIOS fails to give us control of
some other hotplug controller in the system.

Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

 drivers/pci/hotplug/pciehprm_acpi.c |    9 ++++-----
 drivers/pci/pci-acpi.c              |   11 +++--------
 include/linux/pci-acpi.h            |    5 +++--
 3 files changed, 10 insertions(+), 15 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/pciehprm_acpi.c	2005-11-02 10:58:29.000000000 -0800
+++ gregkh-2.6/drivers/pci/hotplug/pciehprm_acpi.c	2005-11-02 10:58:35.000000000 -0800
@@ -143,12 +143,13 @@
 int get_hp_hw_control_from_firmware(struct pci_dev *dev)
 {
 	acpi_status status;
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&(dev->dev));
 	/*
 	 * Per PCI firmware specification, we should run the ACPI _OSC
 	 * method to get control of hotplug hardware before using it
 	 */
-	/* Fixme: run _OSC for a specific host bridge, not all of them */
-	status = pci_osc_control_set(OSC_PCI_EXPRESS_NATIVE_HP_CONTROL);
+	status = pci_osc_control_set(handle,
+			OSC_PCI_EXPRESS_NATIVE_HP_CONTROL);
 
 	/* Fixme: fail native hotplug if _OSC does not exist for root ports */
 	if (status == AE_NOT_FOUND) {
@@ -156,9 +157,7 @@
 		 * Some older BIOS's don't support _OSC but support
 		 * OSHP to do the same thing
 		 */
-		acpi_handle handle = DEVICE_ACPI_HANDLE(&(dev->dev));
-		if (handle)
-			status = acpi_run_oshp(handle);
+		status = acpi_run_oshp(handle);
 	}
 	if (ACPI_FAILURE(status)) {
 		err("Cannot get control of hotplug hardware\n");
--- gregkh-2.6.orig/drivers/pci/pci-acpi.c	2005-08-28 16:41:01.000000000 -0700
+++ gregkh-2.6/drivers/pci/pci-acpi.c	2005-11-02 10:58:35.000000000 -0800
@@ -91,9 +91,7 @@
 static acpi_status  
 acpi_run_osc (
 	acpi_handle	handle,
-	u32		level,
-	void		*context,
-	void		**retval )
+	void		*context)
 {
 	acpi_status		status;
 	struct acpi_object_list	input;
@@ -184,7 +182,7 @@
  *
  * Attempt to take control from Firmware on requested control bits.
  **/
-acpi_status pci_osc_control_set(u32 flags)
+acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status	status;
 	u32		ctrlset;
@@ -198,10 +196,7 @@
 		return AE_SUPPORT;
 	}
 	ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
-	status = acpi_get_devices ( PCI_ROOT_HID_STRING,
-				acpi_run_osc,
-				ctrlset_buf,
-				NULL );
+	status = acpi_run_osc(handle, ctrlset_buf);
 	if (ACPI_FAILURE (status)) {
 		ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
 	}
--- gregkh-2.6.orig/include/linux/pci-acpi.h	2005-08-28 16:41:01.000000000 -0700
+++ gregkh-2.6/include/linux/pci-acpi.h	2005-11-02 10:58:35.000000000 -0800
@@ -47,14 +47,15 @@
 				OSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL)
 
 #ifdef CONFIG_ACPI
-extern acpi_status pci_osc_control_set(u32 flags);
+extern acpi_status pci_osc_control_set(acpi_handle handle, u32 flags);
 extern acpi_status pci_osc_support_set(u32 flags);
 #else
 #if !defined(acpi_status)
 typedef u32 		acpi_status;
 #define AE_ERROR      	(acpi_status) (0x0001)
 #endif    
-static inline acpi_status pci_osc_control_set(u32 flags) {return AE_ERROR;}
+static inline acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
+{return AE_ERROR;}
 static inline acpi_status pci_osc_support_set(u32 flags) {return AE_ERROR;} 
 #endif
 
