From owner-linux-pci@atrey.karlin.mff.cuni.cz Mon Oct 31 16:32:33 2005
Message-Id: <20051101002123.950096242@csdlinux-2.jf.intel.com>
Date: Mon, 31 Oct 2005 16:20:10 -0800
From: rajesh.shah@intel.com
To: kristen.c.accardi@intel.com, gregkh@suse.de
Cc: akpm@osdl.org, rajesh.shah@intel.com
Subject: [patch 5/8] pciehp: reduce debug message verbosity
Content-Disposition: inline; filename=pciehp-reduce-dbg-verbosity

Reduce the number of debug messages generated if pciehp debug is
enabled. I tried to restrict this to removing debug messages that
are either early-driver-debug type messages, or print information
that can be inferred through other debug prints.

Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

 drivers/pci/hotplug/pciehp.h      |    5 ---
 drivers/pci/hotplug/pciehp_core.c |    9 -----
 drivers/pci/hotplug/pciehp_ctrl.c |   24 +++++++--------
 drivers/pci/hotplug/pciehp_hpc.c  |   59 ++++++++++----------------------------
 4 files changed, 28 insertions(+), 69 deletions(-)

--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp.h	2005-11-02 10:58:29.000000000 -0800
+++ gregkh-2.6/drivers/pci/hotplug/pciehp.h	2005-11-02 10:58:33.000000000 -0800
@@ -207,12 +207,9 @@
 
 	p_slot = ctrl->slot;
 
-	dbg("p_slot = %p\n", p_slot);
-
 	while (p_slot && (p_slot->device != device)) {
 		tmp_slot = p_slot;
 		p_slot = p_slot->next;
-		dbg("In while loop, p_slot = %p\n", p_slot);
 	}
 	if (p_slot == NULL) {
 		err("ERROR: pciehp_find_slot device=0x%x\n", device);
@@ -228,7 +225,6 @@
 
 	DECLARE_WAITQUEUE(wait, current);
 
-	dbg("%s : start\n", __FUNCTION__);
 	add_wait_queue(&ctrl->queue, &wait);
 	if (!pciehp_poll_mode)
 		/* Sleep for up to 1 second */
@@ -240,7 +236,6 @@
 	if (signal_pending(current))
 		retval =  -EINTR;
 
-	dbg("%s : end\n", __FUNCTION__);
 	return retval;
 }
 
--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp_core.c	2005-11-02 10:58:29.000000000 -0800
+++ gregkh-2.6/drivers/pci/hotplug/pciehp_core.c	2005-11-02 10:58:33.000000000 -0800
@@ -106,8 +106,6 @@
 	u32 slot_number;
 	int result = -ENOMEM;
 
-	dbg("%s\n",__FUNCTION__);
-
 	number_of_slots = ctrl->num_slots;
 	slot_device = ctrl->slot_device_offset;
 	slot_number = ctrl->first_slot;
@@ -362,7 +360,6 @@
 	u8 value;
 	struct pci_dev *pdev;
 	
-	dbg("%s: Called by hp_drv\n", __FUNCTION__);
 	ctrl = kmalloc(sizeof(*ctrl), GFP_KERNEL);
 	if (!ctrl) {
 		err("%s : out of memory\n", __FUNCTION__);
@@ -370,8 +367,6 @@
 	}
 	memset(ctrl, 0, sizeof(struct controller));
 
-	dbg("%s: DRV_thread pid = %d\n", __FUNCTION__, current->pid);
-	
 	pdev = dev->port;
 	ctrl->pci_dev = pdev;
 
@@ -389,7 +384,6 @@
 		rc = -ENOMEM;
 		goto err_out_unmap_mmio_region;
 	}
-	dbg("%s: ctrl->pci_bus %p\n", __FUNCTION__, ctrl->pci_bus);
 	memcpy (ctrl->pci_bus, pdev->bus, sizeof (*ctrl->pci_bus));
 	ctrl->bus = pdev->bus->number;  /* ctrl bus */
 	ctrl->slot_bus = pdev->subordinate->number;  /* bus controlled by this HPC */
@@ -419,7 +413,6 @@
 	}
 
 	t_slot = pciehp_find_slot(ctrl, first_device_num);
-	dbg("%s: t_slot %p\n", __FUNCTION__, t_slot);
 
 	/*	Finish setting up the hot plug ctrl device */
 	ctrl->next_event = 0;
@@ -436,7 +429,6 @@
 	down(&ctrl->crit_sect);
 
 	t_slot->hpc_ops->get_adapter_status(t_slot, &value); /* Check if slot is occupied */
-	dbg("%s: adpater value %x\n", __FUNCTION__, value);
 	
 	if ((POWER_CTRL(ctrl->ctrlcap)) && !value) {
 		rc = t_slot->hpc_ops->power_off_slot(t_slot); /* Power off slot if not occupied*/
@@ -585,7 +577,6 @@
 	dbg("unload_pciehpd()\n");
 	unload_pciehpd();
 
-	dbg("pcie_port_service_unregister\n");
 	pcie_port_service_unregister(&hpdriver_portdrv);
 
 	info(DRIVER_DESC " version: " DRIVER_VERSION " unloaded\n");
--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp_ctrl.c	2005-11-02 10:58:29.000000000 -0800
+++ gregkh-2.6/drivers/pci/hotplug/pciehp_ctrl.c	2005-11-02 10:58:33.000000000 -0800
@@ -277,7 +277,9 @@
 
 	hp_slot = p_slot->device - ctrl->slot_device_offset;
 
-	dbg("%s: p_slot->device, slot_offset, hp_slot = %d, %d ,%d\n", __FUNCTION__, p_slot->device, ctrl->slot_device_offset, hp_slot);
+	dbg("%s: slot device, slot offset, hp slot = %d, %d ,%d\n",
+			__FUNCTION__, p_slot->device,
+			ctrl->slot_device_offset, hp_slot);
 
 	/* Wait for exclusive access to hardware */
 	down(&ctrl->crit_sect);
@@ -305,9 +307,7 @@
 	up(&ctrl->crit_sect);
 
 	/* Wait for ~1 second */
-	dbg("%s: before long_delay\n", __FUNCTION__);
 	wait_for_ctrl_irq (ctrl);
-	dbg("%s: afterlong_delay\n", __FUNCTION__);
 
 	/*  Check link training status */
 	rc = p_slot->hpc_ops->check_lnk_status(ctrl);  
@@ -444,13 +444,15 @@
 	p_slot->hpc_ops->get_power_status(p_slot, &getstatus);
 	if (getstatus) {
 		p_slot->state = POWEROFF_STATE;
-		dbg("In power_down_board, b:d(%x:%x)\n", p_slot->bus, p_slot->device);
+		dbg("%s: disabling bus:device(%x:%x)\n", __FUNCTION__,
+				p_slot->bus, p_slot->device);
 
 		pciehp_disable_slot(p_slot);
 		p_slot->state = STATIC_STATE;
 	} else {
 		p_slot->state = POWERON_STATE;
-		dbg("In add_board, b:d(%x:%x)\n", p_slot->bus, p_slot->device);
+		dbg("%s: adding bus:device(%x:%x)\n", __FUNCTION__,
+				p_slot->bus, p_slot->device);
 
 		if (pciehp_enable_slot(p_slot) && PWR_LED(p_slot->ctrl->ctrlcap)) {
 			/* Wait for exclusive access to hardware */
@@ -492,13 +494,15 @@
 	p_slot->hpc_ops->get_adapter_status(p_slot, &getstatus);
 	if (!getstatus) {
 		p_slot->state = POWEROFF_STATE;
-		dbg("In removing board, b:d(%x:%x)\n", p_slot->bus, p_slot->device);
+		dbg("%s: removing bus:device(%x:%x)\n",
+				__FUNCTION__, p_slot->bus, p_slot->device);
 
 		pciehp_disable_slot(p_slot);
 		p_slot->state = STATIC_STATE;
 	} else {
 		p_slot->state = POWERON_STATE;
-		dbg("In add_board, b:d(%x:%x)\n", p_slot->bus, p_slot->device);
+		dbg("%s: adding bus:device(%x:%x)\n",
+				__FUNCTION__, p_slot->bus, p_slot->device);
 
 		if (pciehp_enable_slot(p_slot) && PWR_LED(p_slot->ctrl->ctrlcap)) {
 			/* Wait for exclusive access to hardware */
@@ -564,7 +568,6 @@
 		err ("Can't start up our event thread\n");
 		return -1;
 	}
-	dbg("Our event thread pid = %d\n", pid);
 	return 0;
 }
 
@@ -572,9 +575,7 @@
 void pciehp_event_stop_thread(void)
 {
 	event_finished = 1;
-	dbg("event_thread finish command given\n");
 	up(&event_semaphore);
-	dbg("wait for event_thread to exit\n");
 	down(&event_exit);
 }
 
@@ -619,8 +620,6 @@
 
 				p_slot = pciehp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);
 
-				dbg("hp_slot %d, p_slot %p\n", hp_slot, p_slot);
-
 				if (ctrl->event_queue[loop].event_type == INT_BUTTON_CANCEL) {
 					dbg("button cancel\n");
 					del_timer(&p_slot->task_event);
@@ -712,7 +711,6 @@
 						p_slot->task_event.function = (void (*)(unsigned long)) pushbutton_helper_thread;
 						p_slot->task_event.data = (unsigned long) p_slot;
 
-						dbg("add_timer p_slot = %p\n", (void *) p_slot);
 						add_timer(&p_slot->task_event);
 					}
 				}
--- gregkh-2.6.orig/drivers/pci/hotplug/pciehp_hpc.c	2005-11-02 10:58:29.000000000 -0800
+++ gregkh-2.6/drivers/pci/hotplug/pciehp_hpc.c	2005-11-02 10:58:33.000000000 -0800
@@ -274,7 +274,6 @@
 
 	DBG_ENTER_ROUTINE 
 	
-	dbg("%s : Enter\n", __FUNCTION__);
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
 		return -1;
@@ -285,7 +284,6 @@
 			err("%s : hp_register_read_word SLOT_STATUS failed\n", __FUNCTION__);
 			return retval;
 		}
-	dbg("%s : hp_register_read_word SLOT_STATUS %x\n", __FUNCTION__, slot_status);
 	
 	if ((slot_status & CMD_COMPLETED) == CMD_COMPLETED ) { 
 		/* After 1 sec and CMD_COMPLETED still not set, just proceed forward to issue 
@@ -293,14 +291,11 @@
 		dbg("%s : CMD_COMPLETED not clear after 1 sec.\n", __FUNCTION__);
 	}
 
-	dbg("%s: Before hp_register_write_word SLOT_CTRL %x\n", __FUNCTION__, cmd);
 	retval = hp_register_write_word(php_ctlr->pci_dev, SLOT_CTRL(slot->ctrl->cap_base), cmd | CMD_CMPL_INTR_ENABLE);
 	if (retval) {
 		err("%s : hp_register_write_word SLOT_CTRL failed\n", __FUNCTION__);
 		return retval;
 	}
-	dbg("%s : hp_register_write_word SLOT_CTRL %x\n", __FUNCTION__, cmd | CMD_CMPL_INTR_ENABLE);
-	dbg("%s : Exit\n", __FUNCTION__);
 
 	DBG_LEAVE_ROUTINE 
 	return retval;
@@ -516,7 +511,8 @@
 	u16 slot_ctrl;
 	int rc = 0;
 
-	dbg("%s: \n", __FUNCTION__);
+	DBG_ENTER_ROUTINE
+
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
 		return -1;
@@ -532,7 +528,6 @@
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		return rc;
 	}
-	dbg("%s : hp_register_read_word SLOT_CTRL %x\n", __FUNCTION__, slot_ctrl);
 
 	switch (value) {
 		case 0 :	/* turn off */
@@ -553,6 +548,7 @@
 	pcie_write_cmd(slot, slot_cmd);
 	dbg("%s: SLOT_CTRL %x write cmd %x\n", __FUNCTION__, SLOT_CTRL(slot->ctrl->cap_base), slot_cmd);
 	
+	DBG_LEAVE_ROUTINE
 	return rc;
 }
 
@@ -564,7 +560,8 @@
 	u16 slot_ctrl;
 	int rc = 0;
        	
-	dbg("%s: \n", __FUNCTION__);	
+	DBG_ENTER_ROUTINE
+
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
 		return ;
@@ -581,7 +578,6 @@
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		return;
 	}
-	dbg("%s : hp_register_read_word SLOT_CTRL %x\n", __FUNCTION__, slot_ctrl);
 	slot_cmd = (slot_ctrl & ~PWR_LED_CTRL) | 0x0100;
 	if (!pciehp_poll_mode)
 		slot_cmd = slot_cmd | HP_INTR_ENABLE; 
@@ -589,6 +585,7 @@
 	pcie_write_cmd(slot, slot_cmd);
 
 	dbg("%s: SLOT_CTRL %x write cmd %x\n",__FUNCTION__, SLOT_CTRL(slot->ctrl->cap_base), slot_cmd);
+	DBG_LEAVE_ROUTINE
 	return;
 }
 
@@ -599,7 +596,8 @@
 	u16 slot_ctrl;
 	int rc = 0;
 
-	dbg("%s: \n", __FUNCTION__);	
+	DBG_ENTER_ROUTINE
+
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
 		return ;
@@ -616,7 +614,6 @@
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		return;
 	}
-	dbg("%s : hp_register_read_word SLOT_CTRL %x\n", __FUNCTION__, slot_ctrl);
 
 	slot_cmd = (slot_ctrl & ~PWR_LED_CTRL) | 0x0300;
 
@@ -625,6 +622,7 @@
 	pcie_write_cmd(slot, slot_cmd);
 	dbg("%s: SLOT_CTRL %x write cmd %x\n", __FUNCTION__, SLOT_CTRL(slot->ctrl->cap_base), slot_cmd);
 
+	DBG_LEAVE_ROUTINE
 	return;
 }
 
@@ -635,7 +633,8 @@
 	u16 slot_ctrl;
 	int rc = 0; 
 	
-	dbg("%s: \n", __FUNCTION__);	
+	DBG_ENTER_ROUTINE
+
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
 		return ;
@@ -652,7 +651,6 @@
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		return;
 	}
-	dbg("%s : hp_register_read_word SLOT_CTRL %x\n", __FUNCTION__, slot_ctrl);
 
 	slot_cmd = (slot_ctrl & ~PWR_LED_CTRL) | 0x0200;
 
@@ -661,6 +659,7 @@
 	pcie_write_cmd(slot, slot_cmd);
 
 	dbg("%s: SLOT_CTRL %x write cmd %x\n",__FUNCTION__, SLOT_CTRL(slot->ctrl->cap_base), slot_cmd);
+	DBG_LEAVE_ROUTINE
 	return;
 }
 
@@ -757,7 +756,6 @@
 	int retval = 0;
 
 	DBG_ENTER_ROUTINE 
-	dbg("%s: \n", __FUNCTION__);	
 
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
@@ -776,8 +774,6 @@
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		return retval;
 	}
-	dbg("%s: SLOT_CTRL %x, value read %xn", __FUNCTION__, SLOT_CTRL(slot->ctrl->cap_base),
-		slot_ctrl);
 
 	slot_cmd = (slot_ctrl & ~PWR_CTRL) | POWER_ON;
 
@@ -806,7 +802,6 @@
 	int retval = 0;
 
 	DBG_ENTER_ROUTINE 
-	dbg("%s: \n", __FUNCTION__);	
 
 	if (!php_ctlr) {
 		err("%s: Invalid HPC controller handle!\n", __FUNCTION__);
@@ -825,8 +820,6 @@
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		return retval;
 	}
-	dbg("%s: SLOT_CTRL %x, value read %x\n", __FUNCTION__, SLOT_CTRL(slot->ctrl->cap_base),
-		slot_ctrl);
 
 	slot_cmd = (slot_ctrl & ~PWR_CTRL) | POWER_OFF;
 
@@ -901,7 +894,6 @@
 			return IRQ_NONE;
 		}
 
-		dbg("%s: Set Mask Hot-plug Interrupt Enable\n", __FUNCTION__);
 		dbg("%s: hp_register_read_word SLOT_CTRL with value %x\n", __FUNCTION__, temp_word);
 		temp_word = (temp_word & ~HP_INTR_ENABLE & ~CMD_CMPL_INTR_ENABLE) | 0x00;
 
@@ -910,7 +902,6 @@
 			err("%s : hp_register_write_word SLOT_CTRL failed\n", __FUNCTION__);
 			return IRQ_NONE;
 		}
-		dbg("%s: hp_register_write_word SLOT_CTRL with value %x\n", __FUNCTION__, temp_word);
 		
 		rc = hp_register_read_word(php_ctlr->pci_dev, SLOT_STATUS(ctrl->cap_base), slot_status);
 		if (rc) {
@@ -926,14 +917,12 @@
 			err("%s : hp_register_write_word SLOT_STATUS failed\n", __FUNCTION__);
 			return IRQ_NONE;
 		}
-		dbg("%s: hp_register_write_word SLOT_STATUS with value %x\n", __FUNCTION__, temp_word);
 	}
 	
 	if (intr_loc & CMD_COMPLETED) {
 		/* 
 		 * Command Complete Interrupt Pending 
 		 */
-		dbg("%s: In Command Complete Interrupt Pending\n", __FUNCTION__);
 		wake_up_interruptible(&ctrl->queue);
 	}
 
@@ -966,7 +955,6 @@
 		}
 
 		dbg("%s: Unmask Hot-plug Interrupt Enable\n", __FUNCTION__);
-		dbg("%s: hp_register_read_word SLOT_CTRL with value %x\n", __FUNCTION__, temp_word);
 		temp_word = (temp_word & ~HP_INTR_ENABLE) | HP_INTR_ENABLE;
 
 		rc = hp_register_write_word(php_ctlr->pci_dev, SLOT_CTRL(ctrl->cap_base), temp_word);
@@ -974,14 +962,12 @@
 			err("%s : hp_register_write_word SLOT_CTRL failed\n", __FUNCTION__);
 			return IRQ_NONE;
 		}
-		dbg("%s: hp_register_write_word SLOT_CTRL with value %x\n", __FUNCTION__, temp_word); 	
 	
 		rc = hp_register_read_word(php_ctlr->pci_dev, SLOT_STATUS(ctrl->cap_base), slot_status);
 		if (rc) {
 			err("%s : hp_register_read_word SLOT_STATUS failed\n", __FUNCTION__);
 			return IRQ_NONE;
 		}
-		dbg("%s: hp_register_read_word SLOT_STATUS with value %x\n", __FUNCTION__, slot_status); 
 		
 		/* Clear command complete interrupt caused by this write */
 		temp_word = 0x1F;
@@ -1254,8 +1240,8 @@
 	pdev = dev->port;
 	php_ctlr->pci_dev = pdev;	/* save pci_dev in context */
 
-	dbg("%s: pdev->vendor %x pdev->device %x\n", __FUNCTION__,
-		pdev->vendor, pdev->device);
+	dbg("%s: hotplug controller vendor id 0x%x device id 0x%x\n",
+			__FUNCTION__, pdev->vendor, pdev->device);
 
 	saved_cap_base = pcie_cap_base;
 
@@ -1312,8 +1298,6 @@
 		first = 0;
 	}
 
-	dbg("pdev = %p: b:d:f:irq=0x%x:%x:%x:%x\n", pdev, pdev->bus->number, 
-		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), dev->irq);
 	for ( rc = 0; rc < DEVICE_COUNT_RESOURCE; rc++)
 		if (pci_resource_len(pdev, rc) > 0)
 			dbg("pci resource[%d] start=0x%lx(len=0x%lx)\n", rc,
@@ -1331,7 +1315,6 @@
 
 	/* find the IRQ */
 	php_ctlr->irq = dev->irq;
-	dbg("HPC interrupt = %d\n", php_ctlr->irq);
 
 	/* Save interrupt callback info */
 	php_ctlr->attention_button_callback = pciehp_handle_attention_button;
@@ -1359,15 +1342,12 @@
 		err("%s : hp_register_write_word SLOT_CTRL failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s : Mask HPIE hp_register_write_word SLOT_CTRL %x\n", __FUNCTION__, temp_word);
 
 	rc = hp_register_read_word(php_ctlr->pci_dev, SLOT_STATUS(ctrl->cap_base), slot_status);
 	if (rc) {
 		err("%s : hp_register_read_word SLOT_STATUS failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s: Mask HPIE SLOT_STATUS offset %x reads slot_status %x\n", __FUNCTION__, SLOT_STATUS(ctrl->cap_base)
-		, slot_status);
 
 	temp_word = 0x1F; /* Clear all events */
 	rc = hp_register_write_word(php_ctlr->pci_dev, SLOT_STATUS(ctrl->cap_base), temp_word);
@@ -1375,7 +1355,6 @@
 		err("%s : hp_register_write_word SLOT_STATUS failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s: SLOT_STATUS offset %x writes slot_status %x\n", __FUNCTION__, SLOT_STATUS(ctrl->cap_base), temp_word);
 
 	if (pciehp_poll_mode)  {/* Install interrupt polling code */
 		/* Install and start the interrupt polling timer */
@@ -1391,13 +1370,14 @@
 		}
 	}
 
+	dbg("pciehp ctrl b:d:f:irq=0x%x:%x:%x:%x\n", pdev->bus->number,
+		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), dev->irq);
+
 	rc = hp_register_read_word(pdev, SLOT_CTRL(ctrl->cap_base), temp_word);
 	if (rc) {
 		err("%s : hp_register_read_word SLOT_CTRL failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s: SLOT_CTRL %x value read %x\n", __FUNCTION__, SLOT_CTRL(ctrl->cap_base), temp_word);
-	dbg("%s: slot_cap %x\n", __FUNCTION__, slot_cap);
 
 	intr_enable = intr_enable | PRSN_DETECT_ENABLE;
 
@@ -1417,7 +1397,6 @@
 	} else {
 		temp_word = (temp_word & ~HP_INTR_ENABLE) | HP_INTR_ENABLE;
 	}
-	dbg("%s: temp_word %x\n", __FUNCTION__, temp_word);
 
 	/* Unmask Hot-plug Interrupt Enable for the interrupt notification mechanism case */
 	rc = hp_register_write_word(pdev, SLOT_CTRL(ctrl->cap_base), temp_word);
@@ -1425,14 +1404,11 @@
 		err("%s : hp_register_write_word SLOT_CTRL failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s : Unmask HPIE hp_register_write_word SLOT_CTRL with %x\n", __FUNCTION__, temp_word);
 	rc = hp_register_read_word(php_ctlr->pci_dev, SLOT_STATUS(ctrl->cap_base), slot_status);
 	if (rc) {
 		err("%s : hp_register_read_word SLOT_STATUS failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s: Unmask HPIE SLOT_STATUS offset %x reads slot_status %x\n", __FUNCTION__, 
-		SLOT_STATUS(ctrl->cap_base), slot_status);
 	
 	temp_word =  0x1F; /* Clear all events */
 	rc = hp_register_write_word(php_ctlr->pci_dev, SLOT_STATUS(ctrl->cap_base), temp_word);
@@ -1440,7 +1416,6 @@
 		err("%s : hp_register_write_word SLOT_STATUS failed\n", __FUNCTION__);
 		goto abort_free_ctlr;
 	}
-	dbg("%s: SLOT_STATUS offset %x writes slot_status %x\n", __FUNCTION__, SLOT_STATUS(ctrl->cap_base), temp_word);
 	
 	rc = get_hp_hw_control_from_firmware(ctrl->pci_dev);
 	if (rc)
