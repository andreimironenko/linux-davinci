From foo@baz Tue Apr  9 12:12:43 2002
Date: Mon, 9 Apr 2007 11:52:31 -0400 (EDT)
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: USB: remove use of the bus rwsem, as it doesn't really protect anything.

The driver core stopped using the rwsem a long time ago, yet the USB
core still grabbed the lock, thinking it protected something.  As a lock
is really needed for these instances, I've replaced it with a local
mutex to protect the bus, but odds are there is still a code path that
needs to have this lock added to it to properly protect things.

Cc: Alan Stern <stern@rowland.harvard.edu>
Cc: Oliver Neukum <oneukum@suse.de>
Cc: David Brownell <david-b@pacbell.net>
Cc: linux-usb-devel <linux-usb-devel@lists.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/devices.c |    4 ++--
 drivers/usb/core/devio.c   |   20 ++++++++++----------
 drivers/usb/core/message.c |    2 +-
 drivers/usb/core/usb.c     |    3 +++
 drivers/usb/core/usb.h     |    1 +
 5 files changed, 17 insertions(+), 13 deletions(-)

--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -246,7 +246,7 @@ static char *usb_dump_interface_descript
 
 	if (start > end)
 		return start;
-	down_read(&usb_bus_type.subsys.rwsem);
+	mutex_lock(&usb_bus_lock);
 	if (iface) {
 		driver_name = (iface->dev.driver
 				? iface->dev.driver->name
@@ -263,7 +263,7 @@ static char *usb_dump_interface_descript
 			 desc->bInterfaceSubClass,
 			 desc->bInterfaceProtocol,
 			 driver_name);
-	up_read(&usb_bus_type.subsys.rwsem);
+	mutex_unlock(&usb_bus_lock);
 	return start;
 }
 
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -421,13 +421,13 @@ static int claimintf(struct dev_state *p
 		return 0;
 
 	/* lock against other changes to driver bindings */
-	down_write(&usb_bus_type.subsys.rwsem);
+	mutex_lock(&usb_bus_lock);
 	intf = usb_ifnum_to_if(dev, ifnum);
 	if (!intf)
 		err = -ENOENT;
 	else
 		err = usb_driver_claim_interface(&usbfs_driver, intf, ps);
-	up_write(&usb_bus_type.subsys.rwsem);
+	mutex_unlock(&usb_bus_lock);
 	if (err == 0)
 		set_bit(ifnum, &ps->ifclaimed);
 	return err;
@@ -444,7 +444,7 @@ static int releaseintf(struct dev_state 
 		return err;
 	dev = ps->dev;
 	/* lock against other changes to driver bindings */
-	down_write(&usb_bus_type.subsys.rwsem);
+	mutex_lock(&usb_bus_lock);
 	intf = usb_ifnum_to_if(dev, ifnum);
 	if (!intf)
 		err = -ENOENT;
@@ -452,7 +452,7 @@ static int releaseintf(struct dev_state 
 		usb_driver_release_interface(&usbfs_driver, intf);
 		err = 0;
 	}
-	up_write(&usb_bus_type.subsys.rwsem);
+	mutex_unlock(&usb_bus_lock);
 	return err;
 }
 
@@ -818,7 +818,7 @@ static int proc_getdriver(struct dev_sta
 
 	if (copy_from_user(&gd, arg, sizeof(gd)))
 		return -EFAULT;
-	down_read(&usb_bus_type.subsys.rwsem);
+	mutex_lock(&usb_bus_lock);
 	intf = usb_ifnum_to_if(ps->dev, gd.interface);
 	if (!intf || !intf->dev.driver)
 		ret = -ENODATA;
@@ -827,7 +827,7 @@ static int proc_getdriver(struct dev_sta
 				sizeof(gd.driver));
 		ret = (copy_to_user(arg, &gd, sizeof(gd)) ? -EFAULT : 0);
 	}
-	up_read(&usb_bus_type.subsys.rwsem);
+	mutex_unlock(&usb_bus_lock);
 	return ret;
 }
 
@@ -1357,14 +1357,14 @@ static int proc_ioctl(struct dev_state *
 	/* disconnect kernel driver from interface */
 	case USBDEVFS_DISCONNECT:
 
-		down_write(&usb_bus_type.subsys.rwsem);
+		mutex_lock(&usb_bus_lock);
 		if (intf->dev.driver) {
 			driver = to_usb_driver(intf->dev.driver);
 			dev_dbg (&intf->dev, "disconnect by usbfs\n");
 			usb_driver_release_interface(driver, intf);
 		} else
 			retval = -ENODATA;
-		up_write(&usb_bus_type.subsys.rwsem);
+		mutex_unlock(&usb_bus_lock);
 		break;
 
 	/* let kernel drivers try to (re)bind to the interface */
@@ -1376,7 +1376,7 @@ static int proc_ioctl(struct dev_state *
 
 	/* talk directly to the interface's driver */
 	default:
-		down_read(&usb_bus_type.subsys.rwsem);
+		mutex_lock(&usb_bus_lock);
 		if (intf->dev.driver)
 			driver = to_usb_driver(intf->dev.driver);
 		if (driver == NULL || driver->ioctl == NULL) {
@@ -1386,7 +1386,7 @@ static int proc_ioctl(struct dev_state *
 			if (retval == -ENOIOCTLCMD)
 				retval = -ENOTTY;
 		}
-		up_read(&usb_bus_type.subsys.rwsem);
+		mutex_unlock(&usb_bus_lock);
 	}
 
 	/* cleanup and return */
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1410,7 +1410,7 @@ struct device_type usb_if_device_type = 
  *
  * This call is synchronous. The calling context must be able to sleep,
  * must own the device lock, and must not hold the driver model's USB
- * bus rwsem; usb device driver probe() methods cannot use this routine.
+ * bus mutex; usb device driver probe() methods cannot use this routine.
  *
  * Returns zero on success, or else the status code returned by the
  * underlying call that failed.  On successful completion, each interface
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -49,6 +49,8 @@ const char *usbcore_name = "usbcore";
 
 static int nousb;	/* Disable USB when built into kernel image */
 
+struct mutex usb_bus_lock;
+
 /* Workqueue for autosuspend and for remote wakeup of root hubs */
 struct workqueue_struct *ksuspend_usb_wq;
 
@@ -869,6 +871,7 @@ static int __init usb_init(void)
 		return 0;
 	}
 
+	mutex_init(&usb_bus_lock);
 	retval = ksuspend_usb_init();
 	if (retval)
 		goto out;
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -81,6 +81,7 @@ extern struct bus_type usb_bus_type;
 extern struct device_type usb_device_type;
 extern struct device_type usb_if_device_type;
 extern struct usb_device_driver usb_generic_driver;
+extern struct mutex usb_bus_lock;
 
 static inline int is_usb_device(const struct device *dev)
 {
