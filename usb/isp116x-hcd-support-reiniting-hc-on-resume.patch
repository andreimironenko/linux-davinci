From ok@artecdesign.ee Fri Oct 28 05:08:38 2005
Date: Fri, 28 Oct 2005 15:04:45 +0300 (EEST)
From: Olav Kongas <ok@artecdesign.ee>
To: Greg KH <greg@kroah.com>
Subject: [PATCH] isp116x-hcd: support reiniting HC on resume
Message-ID: <Pine.LNX.4.63.0510281453020.23961@pcy.artec.ee>

Until now the isp116x-hcd had no support to reinitialize the HC on
resume, if the controller lost its state during suspend. This patch,
generated against your Oct 26 git tree, adds that support. The patch is
basically the same as the one tested by Ivan Kalatchev, who reported the
problem, on 2.6.13.

Please apply,

Support reinitializing the isp116x host controller from scratch on
resume, if the controller has lost its state.

Signed-off-by: Olav Kongas <ok@artecdesign.ee>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/isp116x-hcd.c |   26 ++++++++++++++++++--------
 1 file changed, 18 insertions(+), 8 deletions(-)

--- gregkh-2.6.orig/drivers/usb/host/isp116x-hcd.c
+++ gregkh-2.6/drivers/usb/host/isp116x-hcd.c
@@ -1201,11 +1201,14 @@ static int isp116x_bus_suspend(struct us
 	return ret;
 }
 
+/* Get rid of these declarations later in cleanup */
+static int isp116x_reset(struct usb_hcd *hcd);
+static int isp116x_start(struct usb_hcd *hcd);
+
 static int isp116x_bus_resume(struct usb_hcd *hcd)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	u32 val;
-	int ret = -EINPROGRESS;
 
 	msleep(5);
 	spin_lock_irq(&isp116x->lock);
@@ -1219,20 +1222,27 @@ static int isp116x_bus_resume(struct usb
 	case HCCONTROL_USB_RESUME:
 		break;
 	case HCCONTROL_USB_OPER:
+		spin_unlock_irq(&isp116x->lock);
 		/* Without setting power_state here the
 		   SUSPENDED state won't be removed from
 		   sysfs/usbN/power.state as a response to remote
 		   wakeup. Maybe in the future. */
 		hcd->self.root_hub->dev.power.power_state = PMSG_ON;
-		ret = 0;
-		break;
+		return 0;
 	default:
-		ret = -EBUSY;
-	}
-
-	if (ret != -EINPROGRESS) {
+		/* HCCONTROL_USB_RESET: this may happen, when during
+		   suspension the HC lost power. Reinitialize completely */
 		spin_unlock_irq(&isp116x->lock);
-		return ret;
+		DBG("Chip has been reset while suspended. Reinit from scratch.\n");
+		isp116x_reset(hcd);
+		isp116x_start(hcd);
+		isp116x_hub_control(hcd, SetPortFeature,
+				    USB_PORT_FEAT_POWER, 1, NULL, 0);
+		if ((isp116x->rhdesca & RH_A_NDP) == 2)
+			isp116x_hub_control(hcd, SetPortFeature,
+					    USB_PORT_FEAT_POWER, 2, NULL, 0);
+		hcd->self.root_hub->dev.power.power_state = PMSG_ON;
+		return 0;
 	}
 
 	val = isp116x->rhdesca & RH_A_NDP;
