From zaitcev@redhat.com Thu May 25 20:09:07 2006
Date: Thu, 25 May 2006 20:08:50 -0700
From: Pete Zaitcev <zaitcev@redhat.com>
To: greg@kroah.com
Cc: zaitcev@redhat.com
Subject: ub: random cleanups
Message-Id: <20060525200850.f67fe6b7.zaitcev@redhat.com>

Remove some silly messages and cast in stone "temporary" messages which
we keep around. Also, I am hesitant to remove the initialization retries
without having the hardware to test (anyone who was at KS04 has a spare?)

Signed-off-by: Pete Zaitcev <zaitcev@yahoo.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/block/ub.c |   60 ++++++++++-------------------------------------------
 1 file changed, 12 insertions(+), 48 deletions(-)

--- gregkh-2.6.orig/drivers/block/ub.c
+++ gregkh-2.6/drivers/block/ub.c
@@ -10,17 +10,13 @@
  * TODO (sorted by decreasing priority)
  *  -- set readonly flag for CDs, set removable flag for CF readers
  *  -- do inquiry and verify we got a disk and not a tape (for LUN mismatch)
- *  -- special case some senses, e.g. 3a/0 -> no media present, reduce retries
  *  -- verify the 13 conditions and do bulk resets
- *  -- kill last_pipe and simply do two-state clearing on both pipes
  *  -- highmem
  *  -- move top_sense and work_bcs into separate allocations (if they survive)
  *     for cache purists and esoteric architectures.
  *  -- Allocate structure for LUN 0 before the first ub_sync_tur, avoid NULL. ?
  *  -- prune comments, they are too volumnous
- *  -- Exterminate P3 printks
  *  -- Resove XXX's
- *  -- Redo "benh's retries", perhaps have spin-up code to handle them. V:D=?
  *  -- CLEAR, CLR2STS, CLRRS seem to be ripe for refactoring.
  */
 #include <linux/kernel.h>
@@ -180,7 +176,6 @@ struct ub_dev;
 #define UB_DIR_ILLEGAL2	2
 #define UB_DIR_WRITE	3
 
-/* P3 */
 #define UB_DIR_CHAR(c)  (((c)==UB_DIR_WRITE)? 'w': \
 			 (((c)==UB_DIR_READ)? 'r': 'n'))
 
@@ -669,8 +664,9 @@ static int ub_request_fn_1(struct ub_lun
 	 */
 	n_elem = blk_rq_map_sg(lun->disk->queue, rq, &urq->sgv[0]);
 	if (n_elem < 0) {
+		/* Impossible, because blk_rq_map_sg should not hit ENOMEM. */
 		printk(KERN_INFO "%s: failed request map (%d)\n",
-		    lun->name, n_elem); /* P3 */
+		    lun->name, n_elem);
 		goto drop;
 	}
 	if (n_elem > UB_MAX_REQ_SG) {	/* Paranoia */
@@ -824,7 +820,9 @@ static int ub_rw_cmd_retry(struct ub_dev
 	if (urq->current_try >= 3)
 		return -EIO;
 	urq->current_try++;
-	/* P3 */ printk("%s: dir %c len/act %d/%d "
+
+	/* Remove this if anyone complains of flooding. */
+	printk(KERN_DEBUG "%s: dir %c len/act %d/%d "
 	    "[sense %x %02x %02x] retry %d\n",
 	    sc->name, UB_DIR_CHAR(cmd->dir), cmd->len, cmd->act_len,
 	    cmd->key, cmd->asc, cmd->ascq, urq->current_try);
@@ -1241,8 +1239,6 @@ static void ub_scsi_urb_compl(struct ub_
 			 * to check. But it's not all right if the device
 			 * counts disagree with our counts.
 			 */
-			/* P3 */ printk("%s: resid %d len %d act %d\n",
-			    sc->name, len, cmd->len, cmd->act_len);
 			goto Bad_End;
 		}
 
@@ -1253,7 +1249,6 @@ static void ub_scsi_urb_compl(struct ub_
 			ub_state_sense(sc, cmd);
 			return;
 		case US_BULK_STAT_PHASE:
-			/* P3 */ printk("%s: status PHASE\n", sc->name);
 			goto Bad_End;
 		default:
 			printk(KERN_INFO "%s: unknown CSW status 0x%x\n",
@@ -1568,16 +1563,14 @@ static void ub_reset_task(void *arg)
 	}
 
 	if (atomic_read(&sc->poison)) {
-		printk(KERN_NOTICE "%s: Not resetting disconnected device\n",
-		    sc->name); /* P3 This floods. Remove soon. XXX */
+		;
 	} else if ((sc->reset & 1) == 0) {
 		ub_sync_reset(sc);
 		msleep(700);	/* usb-storage sleeps 6s (!) */
 		ub_probe_clear_stall(sc, sc->recv_bulk_pipe);
 		ub_probe_clear_stall(sc, sc->send_bulk_pipe);
 	} else if (sc->dev->actconfig->desc.bNumInterfaces != 1) {
-		printk(KERN_NOTICE "%s: Not resetting multi-interface device\n",
-		    sc->name); /* P3 This floods. Remove soon. XXX */
+		;
 	} else {
 		if ((lkr = usb_lock_device_for_reset(sc->dev, sc->intf)) < 0) {
 			printk(KERN_NOTICE
@@ -1819,10 +1812,8 @@ static int ub_sync_tur(struct ub_dev *sc
 	rc = ub_submit_scsi(sc, cmd);
 	spin_unlock_irqrestore(sc->lock, flags);
 
-	if (rc != 0) {
-		printk("ub: testing ready: submit error (%d)\n", rc); /* P3 */
+	if (rc != 0)
 		goto err_submit;
-	}
 
 	wait_for_completion(&compl);
 
@@ -1880,20 +1871,16 @@ static int ub_sync_read_cap(struct ub_de
 	rc = ub_submit_scsi(sc, cmd);
 	spin_unlock_irqrestore(sc->lock, flags);
 
-	if (rc != 0) {
-		printk("ub: reading capacity: submit error (%d)\n", rc); /* P3 */
+	if (rc != 0)
 		goto err_submit;
-	}
 
 	wait_for_completion(&compl);
 
 	if (cmd->error != 0) {
-		printk("ub: reading capacity: error %d\n", cmd->error); /* P3 */
 		rc = -EIO;
 		goto err_read;
 	}
 	if (cmd->act_len != 8) {
-		printk("ub: reading capacity: size %d\n", cmd->act_len); /* P3 */
 		rc = -EIO;
 		goto err_read;
 	}
@@ -1907,7 +1894,6 @@ static int ub_sync_read_cap(struct ub_de
 	case 2048:	shift = 2;	break;
 	case 4096:	shift = 3;	break;
 	default:
-		printk("ub: Bad sector size %u\n", bsize); /* P3 */
 		rc = -EDOM;
 		goto err_inv_bsize;
 	}
@@ -2019,17 +2005,8 @@ static int ub_sync_getmaxlun(struct ub_d
 	sc->work_urb.error_count = 0;
 	sc->work_urb.status = 0;
 
-	if ((rc = usb_submit_urb(&sc->work_urb, GFP_KERNEL)) != 0) {
-		if (rc == -EPIPE) {
-			printk("%s: Stall submitting GetMaxLUN, using 1 LUN\n",
-			     sc->name); /* P3 */
-		} else {
-			printk(KERN_NOTICE
-			     "%s: Unable to submit GetMaxLUN (%d)\n",
-			     sc->name, rc);
-		}
+	if ((rc = usb_submit_urb(&sc->work_urb, GFP_KERNEL)) != 0)
 		goto err_submit;
-	}
 
 	init_timer(&timer);
 	timer.function = ub_probe_timeout;
@@ -2042,21 +2019,10 @@ static int ub_sync_getmaxlun(struct ub_d
 	del_timer_sync(&timer);
 	usb_kill_urb(&sc->work_urb);
 
-	if ((rc = sc->work_urb.status) < 0) {
-		if (rc == -EPIPE) {
-			printk("%s: Stall at GetMaxLUN, using 1 LUN\n",
-			     sc->name); /* P3 */
-		} else {
-			printk(KERN_NOTICE
-			     "%s: Error at GetMaxLUN (%d)\n",
-			     sc->name, rc);
-		}
+	if ((rc = sc->work_urb.status) < 0)
 		goto err_io;
-	}
 
 	if (sc->work_urb.actual_length != 1) {
-		printk("%s: GetMaxLUN returned %d bytes\n", sc->name,
-		    sc->work_urb.actual_length); /* P3 */
 		nluns = 0;
 	} else {
 		if ((nluns = *p) == 55) {
@@ -2067,8 +2033,6 @@ static int ub_sync_getmaxlun(struct ub_d
 			if (nluns > UB_MAX_LUNS)
 				nluns = UB_MAX_LUNS;
 		}
-		printk("%s: GetMaxLUN returned %d, using %d LUNs\n", sc->name,
-		    *p, nluns); /* P3 */
 	}
 
 	kfree(p);
@@ -2266,7 +2230,7 @@ static int ub_probe(struct usb_interface
 	 * has to succeed, so we clear checks with an additional one here.
 	 * In any case it's not our business how revaliadation is implemented.
 	 */
-	for (i = 0; i < 3; i++) {	/* Retries for benh's key */
+	for (i = 0; i < 3; i++) {  /* Retries for the schwag key from KS'04 */
 		if ((rc = ub_sync_tur(sc, NULL)) <= 0) break;
 		if (rc != 0x6) break;
 		msleep(10);
