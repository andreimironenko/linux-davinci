From stern@rowland.harvard.edu Tue Sep 26 11:50:30 2006
Date: Tue, 26 Sep 2006 14:50:20 -0400 (EDT)
From: Alan Stern <stern@rowland.harvard.edu>
To: Greg KH <greg@kroah.com>, Andrew Morton <akpm@osdl.org>
Subject: USB: fix autosuspend when CONFIG_PM isn't set
Message-ID: <Pine.LNX.4.44L0.0609261446180.5787-100000@iolanthe.rowland.org>

This patch (as791b) fixes things up to avoid compiler warnings or
errors when CONFIG_USB_SUSPEND or CONFIG_PM isn't set.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/driver.c |   42 +++++++++++++++++++++---------------------
 drivers/usb/core/hub.c    |    4 ++--
 drivers/usb/core/usb.c    |    4 ++--
 drivers/usb/core/usb.h    |   18 +++++++++++++++++-
 include/linux/usb.h       |    2 +-
 5 files changed, 43 insertions(+), 27 deletions(-)

--- gregkh-2.6.orig/drivers/usb/core/driver.c
+++ gregkh-2.6/drivers/usb/core/driver.c
@@ -303,11 +303,11 @@ int usb_driver_claim_interface(struct us
 	dev->driver = &driver->drvwrap.driver;
 	usb_set_intfdata(iface, priv);
 
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	iface->condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
 	iface->pm_usage_cnt = !(driver->supports_autosuspend);
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
@@ -356,11 +356,11 @@ void usb_driver_release_interface(struct
 	dev->driver = NULL;
 	usb_set_intfdata(iface, NULL);
 
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	iface->condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(iface);
 	iface->needs_remote_wakeup = 0;
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 }
 EXPORT_SYMBOL(usb_driver_release_interface);
 
@@ -789,7 +789,7 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister)
 
 #ifdef CONFIG_PM
 
-/* Caller has locked udev->pm_mutex */
+/* Caller has locked udev's pm_mutex */
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -816,7 +816,7 @@ done:
 	return status;
 }
 
-/* Caller has locked udev->pm_mutex */
+/* Caller has locked udev's pm_mutex */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
@@ -842,7 +842,7 @@ done:
 	return status;
 }
 
-/* Caller has locked intf's usb_device's pm_mutex */
+/* Caller has locked intf's usb_device's pm mutex */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -1064,7 +1064,7 @@ int usb_resume_both(struct usb_device *u
 	/* Propagate the resume up the tree, if necessary */
 	if (udev->state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			mutex_lock_nested(&parent->pm_mutex, parent->level);
+			usb_pm_lock(parent);
 			parent->auto_pm = 1;
 			status = usb_resume_both(parent);
 		} else {
@@ -1079,7 +1079,7 @@ int usb_resume_both(struct usb_device *u
 		if (status == 0)
 			status = resume_device(udev);
 		if (parent)
-			mutex_unlock(&parent->pm_mutex);
+			usb_pm_unlock(parent);
 	} else {
 
 		/* Needed only for setting udev->dev.power.power_state.event
@@ -1129,12 +1129,12 @@ int usb_resume_both(struct usb_device *u
  */
 void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 {
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	udev->pm_usage_cnt -= dec_usage_cnt;
 	if (udev->pm_usage_cnt <= 0)
 		queue_delayed_work(ksuspend_usb_wq, &udev->autosuspend,
 				USB_AUTOSUSPEND_DELAY);
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&udev->dev, "%s: cnt %d\n",
 	//		__FUNCTION__, udev->pm_usage_cnt);
 }
@@ -1168,13 +1168,13 @@ int usb_autoresume_device(struct usb_dev
 {
 	int	status;
 
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	udev->pm_usage_cnt += inc_usage_cnt;
 	udev->auto_pm = 1;
 	status = usb_resume_both(udev);
 	if (status != 0)
 		udev->pm_usage_cnt -= inc_usage_cnt;
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&udev->dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, udev->pm_usage_cnt);
 	return status;
@@ -1215,13 +1215,13 @@ void usb_autopm_put_interface(struct usb
 {
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	if (intf->condition != USB_INTERFACE_UNBOUND &&
 			--intf->pm_usage_cnt <= 0) {
 		queue_delayed_work(ksuspend_usb_wq, &udev->autosuspend,
 				USB_AUTOSUSPEND_DELAY);
 	}
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&intf->dev, "%s: cnt %d\n",
 	//		__FUNCTION__, intf->pm_usage_cnt);
 }
@@ -1263,7 +1263,7 @@ int usb_autopm_get_interface(struct usb_
 	struct usb_device	*udev = interface_to_usbdev(intf);
 	int			status;
 
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	if (intf->condition == USB_INTERFACE_UNBOUND)
 		status = -ENODEV;
 	else {
@@ -1273,7 +1273,7 @@ int usb_autopm_get_interface(struct usb_
 		if (status != 0)
 			--intf->pm_usage_cnt;
 	}
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&intf->dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, intf->pm_usage_cnt);
 	return status;
@@ -1289,10 +1289,10 @@ static int usb_suspend(struct device *de
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		mutex_lock_nested(&udev->pm_mutex, udev->level);
+		usb_pm_lock(udev);
 		udev->auto_pm = 0;
 		status = usb_suspend_both(udev, message);
-		mutex_unlock(&udev->pm_mutex);
+		usb_pm_unlock(udev);
 	} else
 		status = 0;
 	return status;
@@ -1305,10 +1305,10 @@ static int usb_resume(struct device *dev
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		mutex_lock_nested(&udev->pm_mutex, udev->level);
+		usb_pm_lock(udev);
 		udev->auto_pm = 0;
 		status = usb_resume_both(udev);
-		mutex_unlock(&udev->pm_mutex);
+		usb_pm_unlock(udev);
 
 		/* Rebind drivers that had no suspend method? */
 	} else
--- gregkh-2.6.orig/drivers/usb/core/hub.c
+++ gregkh-2.6/drivers/usb/core/hub.c
@@ -1816,7 +1816,7 @@ static int remote_wakeup(struct usb_devi
 	 * to the parent hub! */
 
 	usb_lock_device(udev);
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	if (udev->state == USB_STATE_SUSPENDED) {
 		dev_dbg(&udev->dev, "usb %sresume\n", "wakeup-");
 		/* TRSMRCY = 10 msec */
@@ -1825,7 +1825,7 @@ static int remote_wakeup(struct usb_devi
 		if (status == 0)
 			udev->dev.power.power_state.event = PM_EVENT_ON;
 	}
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 
 	if (status == 0)
 		usb_autoresume_device(udev, 0);
--- gregkh-2.6.orig/drivers/usb/core/usb.c
+++ gregkh-2.6/drivers/usb/core/usb.c
@@ -214,10 +214,10 @@ static void usb_autosuspend_work(void *_
 {
 	struct usb_device	*udev = _udev;
 
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
+	usb_pm_lock(udev);
 	udev->auto_pm = 1;
 	usb_suspend_both(udev, PMSG_SUSPEND);
-	mutex_unlock(&udev->pm_mutex);
+	usb_pm_unlock(udev);
 }
 
 #else
--- gregkh-2.6.orig/drivers/usb/core/usb.h
+++ gregkh-2.6/drivers/usb/core/usb.h
@@ -36,6 +36,16 @@ extern int usb_resume_both(struct usb_de
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+static inline void usb_pm_lock(struct usb_device *udev)
+{
+	mutex_lock_nested(&udev->pm_mutex, udev->level);
+}
+
+static inline void usb_pm_unlock(struct usb_device *udev)
+{
+	mutex_unlock(&udev->pm_mutex);
+}
+
 #else
 
 #define usb_suspend_both(udev, msg)	0
@@ -45,6 +55,8 @@ static inline int usb_resume_both(struct
 }
 #define usb_port_suspend(dev)		0
 #define usb_port_resume(dev)		0
+static inline void usb_pm_lock(struct usb_device *udev) {}
+static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #endif
 
@@ -58,7 +70,11 @@ extern int usb_autoresume_device(struct 
 #else
 
 #define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-#define usb_autoresume_device(udev, inc_busy_cnt)	0
+static inline int usb_autoresume_device(struct usb_device *udev,
+		int inc_busy_cnt)
+{
+	return 0;
+}
 
 #endif
 
--- gregkh-2.6.orig/include/linux/usb.h
+++ gregkh-2.6/include/linux/usb.h
@@ -380,10 +380,10 @@ struct usb_device {
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
 
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 #ifdef CONFIG_PM
 	struct work_struct autosuspend;	/* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
-	int pm_usage_cnt;		/* usage counter for autosuspend */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
