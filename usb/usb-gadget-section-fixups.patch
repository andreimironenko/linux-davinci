From david-b@pacbell.net Thu Jul  6 15:48:59 2006
From: David Brownell <david-b@pacbell.net>
To: Greg KH <greg@kroah.com>
Subject: USB: gadget section fixups
Date: Thu, 6 Jul 2006 15:48:53 -0700
Message-Id: <200607061548.53496.david-b@pacbell.net>

Recent section changes broke gadget builds on some platforms.  This patch
is the best fix that's available until better section markings exist:

 - There's a lot of cleanup code that gets used in both init and exit paths;
   stop marking it as "__exit".

   (Best fix for this would be an "__init_or_exit" section marking, putting
   the cleanup in __init when __exit sections get discarded else in __exit.)

 - Stop marking the use-once probe routines as "__init" since references
   to those routines are not allowed from driver structures.  They're now
   marked "__devinit", which in practice is a net lose.

   (Best fix for this is likely to separate such use-once probe routines
   from the driver structure ... but in general, all busses that aren't
   hotpluggable will be forced to waste memory for all probe-only code.)

In general these broken section rules waste an average of two to four kBytes
per driver of code bloat ... because none of the relevant code can ever be
reused after module initialization.

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/epautoconf.c   |   16 ++++++++--------
 drivers/usb/gadget/ether.c        |    8 ++++----
 drivers/usb/gadget/file_storage.c |    2 +-
 drivers/usb/gadget/rndis.c        |    2 +-
 drivers/usb/gadget/rndis.h        |    2 +-
 drivers/usb/gadget/serial.c       |    2 +-
 drivers/usb/gadget/zero.c         |    2 +-
 include/linux/usb_gadget.h        |    4 ++--
 8 files changed, 19 insertions(+), 19 deletions(-)

--- gregkh-2.6.orig/drivers/usb/gadget/epautoconf.c
+++ gregkh-2.6/drivers/usb/gadget/epautoconf.c
@@ -34,12 +34,12 @@
 
 
 /* we must assign addresses for configurable endpoints (like net2280) */
-static __initdata unsigned epnum;
+static __devinitdata unsigned epnum;
 
 // #define MANY_ENDPOINTS
 #ifdef MANY_ENDPOINTS
 /* more than 15 configurable endpoints */
-static __initdata unsigned in_epnum;
+static __devinitdata unsigned in_epnum;
 #endif
 
 
@@ -59,7 +59,7 @@ static __initdata unsigned in_epnum;
  * NOTE:  each endpoint is unidirectional, as specified by its USB
  * descriptor; and isn't specific to a configuration or altsetting.
  */
-static int __init
+static int __devinit
 ep_matches (
 	struct usb_gadget		*gadget,
 	struct usb_ep			*ep,
@@ -73,7 +73,7 @@ ep_matches (
 	/* endpoint already claimed? */
 	if (0 != ep->driver_data)
 		return 0;
-		
+
 	/* only support ep0 for portable CONTROL traffic */
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 	if (USB_ENDPOINT_XFER_CONTROL == type)
@@ -186,7 +186,7 @@ ep_matches (
 	return 1;
 }
 
-static struct usb_ep * __init
+static struct usb_ep * __devinit
 find_ep (struct usb_gadget *gadget, const char *name)
 {
 	struct usb_ep	*ep;
@@ -228,7 +228,7 @@ find_ep (struct usb_gadget *gadget, cons
  *
  * On failure, this returns a null endpoint descriptor.
  */
-struct usb_ep * __init usb_ep_autoconfig (
+struct usb_ep * __devinit usb_ep_autoconfig (
 	struct usb_gadget		*gadget,
 	struct usb_endpoint_descriptor	*desc
 )
@@ -276,7 +276,7 @@ struct usb_ep * __init usb_ep_autoconfig
 			return ep;
 	}
 
-	/* Second, look at endpoints until an unclaimed one looks usable */ 
+	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
 		if (ep_matches (gadget, ep, desc))
 			return ep;
@@ -295,7 +295,7 @@ struct usb_ep * __init usb_ep_autoconfig
  * state such as ep->driver_data and the record of assigned endpoints
  * used by usb_ep_autoconfig().
  */
-void __init usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+void __devinit usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 {
 	struct usb_ep	*ep;
 
--- gregkh-2.6.orig/drivers/usb/gadget/ether.c
+++ gregkh-2.6/drivers/usb/gadget/ether.c
@@ -2131,7 +2131,7 @@ eth_req_free (struct usb_ep *ep, struct 
 }
 
 
-static void __exit
+static void /* __init_or_exit */
 eth_unbind (struct usb_gadget *gadget)
 {
 	struct eth_dev		*dev = get_gadget_data (gadget);
@@ -2158,7 +2158,7 @@ eth_unbind (struct usb_gadget *gadget)
 	set_gadget_data (gadget, NULL);
 }
 
-static u8 __init nibble (unsigned char c)
+static u8 __devinit nibble (unsigned char c)
 {
 	if (likely (isdigit (c)))
 		return c - '0';
@@ -2168,7 +2168,7 @@ static u8 __init nibble (unsigned char c
 	return 0;
 }
 
-static int __init get_ether_addr(const char *str, u8 *dev_addr)
+static int __devinit get_ether_addr(const char *str, u8 *dev_addr)
 {
 	if (str) {
 		unsigned	i;
@@ -2189,7 +2189,7 @@ static int __init get_ether_addr(const c
 	return 1;
 }
 
-static int __init
+static int __devinit
 eth_bind (struct usb_gadget *gadget)
 {
 	struct eth_dev		*dev;
--- gregkh-2.6.orig/drivers/usb/gadget/file_storage.c
+++ gregkh-2.6/drivers/usb/gadget/file_storage.c
@@ -3691,7 +3691,7 @@ static void lun_release(struct device *d
 	kref_put(&fsg->ref, fsg_release);
 }
 
-static void __exit fsg_unbind(struct usb_gadget *gadget)
+static void /* __init_or_exit */ fsg_unbind(struct usb_gadget *gadget)
 {
 	struct fsg_dev		*fsg = get_gadget_data(gadget);
 	int			i;
--- gregkh-2.6.orig/drivers/usb/gadget/rndis.c
+++ gregkh-2.6/drivers/usb/gadget/rndis.c
@@ -1398,7 +1398,7 @@ static struct proc_dir_entry *rndis_conn
 #endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
 
 
-int __init rndis_init (void)
+int __devinit rndis_init (void)
 {
 	u8 i;
 
--- gregkh-2.6.orig/drivers/usb/gadget/rndis.h
+++ gregkh-2.6/drivers/usb/gadget/rndis.h
@@ -264,7 +264,7 @@ int  rndis_signal_disconnect (int config
 int  rndis_state (int configNr);
 extern void rndis_set_host_mac (int configNr, const u8 *addr);
 
-int __init rndis_init (void);
+int __devinit rndis_init (void);
 void rndis_exit (void);
 
 #endif  /* _LINUX_RNDIS_H */
--- gregkh-2.6.orig/drivers/usb/gadget/serial.c
+++ gregkh-2.6/drivers/usb/gadget/serial.c
@@ -1473,7 +1473,7 @@ autoconf_fail:
  * Called on module unload.  Frees the control request and device
  * structure.
  */
-static void __exit gs_unbind(struct usb_gadget *gadget)
+static void /* __init_or_exit */ gs_unbind(struct usb_gadget *gadget)
 {
 	struct gs_dev *dev = get_gadget_data(gadget);
 
--- gregkh-2.6.orig/drivers/usb/gadget/zero.c
+++ gregkh-2.6/drivers/usb/gadget/zero.c
@@ -1121,7 +1121,7 @@ zero_autoresume (unsigned long _dev)
 
 /*-------------------------------------------------------------------------*/
 
-static void __exit
+static void /* __init_or_exit */
 zero_unbind (struct usb_gadget *gadget)
 {
 	struct zero_dev		*dev = get_gadget_data (gadget);
--- gregkh-2.6.orig/include/linux/usb_gadget.h
+++ gregkh-2.6/include/linux/usb_gadget.h
@@ -872,9 +872,9 @@ int usb_gadget_config_buf(const struct u
 /* utility wrapping a simple endpoint selection policy */
 
 extern struct usb_ep *usb_ep_autoconfig (struct usb_gadget *,
-			struct usb_endpoint_descriptor *) __init;
+			struct usb_endpoint_descriptor *) __devinit;
 
-extern void usb_ep_autoconfig_reset (struct usb_gadget *) __init;
+extern void usb_ep_autoconfig_reset (struct usb_gadget *) __devinit;
 
 #endif  /* __KERNEL__ */
 
