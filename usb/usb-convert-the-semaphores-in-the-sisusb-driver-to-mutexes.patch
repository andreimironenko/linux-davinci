From akpm@osdl.org Tue Mar 28 01:00:43 2006
Message-Id: <200603280900.k2S90OQh026084@shell0.pdx.osdl.net>
Subject: USB: convert the semaphores in the sisusb driver to mutexes
To: greg@kroah.com
Cc: akpm@osdl.org, arjan@infradead.org
From: akpm@osdl.org
Date: Tue, 28 Mar 2006 01:00:21 -0800


From: Arjan van de Ven <arjan@infradead.org>

Convert the semaphores-used-as-mutex to mutexes in the sisusb video driver;
this required manual checking due to the "return as locked" stuff in this
driver, but the ->lock semaphore is still used as mutex in the end.

Signed-off-by: Arjan van de Ven <arjan@infradead.org>
Cc: Thomas Winischhofer <winischhofer.net>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/misc/sisusbvga/sisusb.c     |   77 +++++++++----------
 drivers/usb/misc/sisusbvga/sisusb.h     |    4 
 drivers/usb/misc/sisusbvga/sisusb_con.c |  129 ++++++++++++++++----------------
 3 files changed, 107 insertions(+), 103 deletions(-)

--- gregkh-2.6.orig/drivers/usb/misc/sisusbvga/sisusb.c
+++ gregkh-2.6/drivers/usb/misc/sisusbvga/sisusb.c
@@ -37,6 +37,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/mutex.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
@@ -102,7 +103,7 @@ MODULE_PARM_DESC(last, "Number of last c
 
 static struct usb_driver sisusb_driver;
 
-DECLARE_MUTEX(disconnect_sem);
+DEFINE_MUTEX(disconnect_mutex);
 
 static void
 sisusb_free_buffers(struct sisusb_usb_data *sisusb)
@@ -2552,39 +2553,39 @@ sisusb_open(struct inode *inode, struct 
 	struct usb_interface *interface;
 	int subminor = iminor(inode);
 
-	down(&disconnect_sem);
+	mutex_lock(&disconnect_mutex);
 
 	if (!(interface = usb_find_interface(&sisusb_driver, subminor))) {
 		printk(KERN_ERR "sisusb[%d]: Failed to find interface\n",
 				subminor);
-		up(&disconnect_sem);
+		mutex_unlock(&disconnect_mutex);
 		return -ENODEV;
 	}
 
 	if (!(sisusb = usb_get_intfdata(interface))) {
-		up(&disconnect_sem);
+		mutex_unlock(&disconnect_mutex);
 		return -ENODEV;
 	}
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	if (!sisusb->present || !sisusb->ready) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		return -ENODEV;
 	}
 
 	if (sisusb->isopen) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		return -EBUSY;
 	}
 
 	if (!sisusb->devinit) {
 		if (sisusb->sisusb_dev->speed == USB_SPEED_HIGH) {
 			if (sisusb_init_gfxdevice(sisusb, 0)) {
-				up(&sisusb->lock);
-				up(&disconnect_sem);
+				mutex_unlock(&sisusb->lock);
+				mutex_unlock(&disconnect_mutex);
 				printk(KERN_ERR
 					"sisusbvga[%d]: Failed to initialize "
 					"device\n",
@@ -2592,8 +2593,8 @@ sisusb_open(struct inode *inode, struct 
 				return -EIO;
 			}
 		} else {
-			up(&sisusb->lock);
-			up(&disconnect_sem);
+			mutex_unlock(&sisusb->lock);
+			mutex_unlock(&disconnect_mutex);
 			printk(KERN_ERR
 				"sisusbvga[%d]: Device not attached to "
 				"USB 2.0 hub\n",
@@ -2609,9 +2610,9 @@ sisusb_open(struct inode *inode, struct 
 
 	file->private_data = sisusb;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
-	up(&disconnect_sem);
+	mutex_unlock(&disconnect_mutex);
 
 	return 0;
 }
@@ -2642,14 +2643,14 @@ sisusb_release(struct inode *inode, stru
 	struct sisusb_usb_data *sisusb;
 	int myminor;
 
-	down(&disconnect_sem);
+	mutex_lock(&disconnect_mutex);
 
 	if (!(sisusb = (struct sisusb_usb_data *)file->private_data)) {
-		up(&disconnect_sem);
+		mutex_unlock(&disconnect_mutex);
 		return -ENODEV;
 	}
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	if (sisusb->present) {
 		/* Wait for all URBs to finish if device still present */
@@ -2662,12 +2663,12 @@ sisusb_release(struct inode *inode, stru
 	sisusb->isopen = 0;
 	file->private_data = NULL;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	/* decrement the usage count on our device */
 	kref_put(&sisusb->kref, sisusb_delete);
 
-	up(&disconnect_sem);
+	mutex_unlock(&disconnect_mutex);
 
 	return 0;
 }
@@ -2685,11 +2686,11 @@ sisusb_read(struct file *file, char __us
 	if (!(sisusb = (struct sisusb_usb_data *)file->private_data))
 		return -ENODEV;
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Sanity check */
 	if (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return -ENODEV;
 	}
 
@@ -2784,7 +2785,7 @@ sisusb_read(struct file *file, char __us
 		    (*ppos) <= SISUSB_PCI_PSEUDO_PCIBASE + 0x5c) {
 
 		if (count != 4) {
-			up(&sisusb->lock);
+			mutex_unlock(&sisusb->lock);
 			return -EINVAL;
 		}
 
@@ -2808,7 +2809,7 @@ sisusb_read(struct file *file, char __us
 
 	(*ppos) += bytes_read;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return errno ? errno : bytes_read;
 }
@@ -2827,11 +2828,11 @@ sisusb_write(struct file *file, const ch
 	if (!(sisusb = (struct sisusb_usb_data *)file->private_data))
 		return -ENODEV;
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Sanity check */
 	if (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return -ENODEV;
 	}
 
@@ -2930,7 +2931,7 @@ sisusb_write(struct file *file, const ch
 		    (*ppos) <= SISUSB_PCI_PSEUDO_PCIBASE + SISUSB_PCI_PCONFSIZE) {
 
 		if (count != 4) {
-			up(&sisusb->lock);
+			mutex_unlock(&sisusb->lock);
 			return -EINVAL;
 		}
 
@@ -2956,7 +2957,7 @@ sisusb_write(struct file *file, const ch
 
 	(*ppos) += bytes_written;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return errno ? errno : bytes_written;
 }
@@ -2970,11 +2971,11 @@ sisusb_lseek(struct file *file, loff_t o
 	if (!(sisusb = (struct sisusb_usb_data *)file->private_data))
 		return -ENODEV;
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Sanity check */
 	if (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return -ENODEV;
 	}
 
@@ -2994,7 +2995,7 @@ sisusb_lseek(struct file *file, loff_t o
 			ret = -EINVAL;
 	}
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 	return ret;
 }
 
@@ -3136,7 +3137,7 @@ sisusb_ioctl(struct inode *inode, struct
 	if (!(sisusb = (struct sisusb_usb_data *)file->private_data))
 		return -ENODEV;
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Sanity check */
 	if (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {
@@ -3193,7 +3194,7 @@ sisusb_ioctl(struct inode *inode, struct
 	}
 
 err_out:
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 	return retval;
 }
 
@@ -3258,7 +3259,7 @@ static int sisusb_probe(struct usb_inter
 	}
 	kref_init(&sisusb->kref);
 
-	init_MUTEX(&(sisusb->lock));
+	mutex_init(&(sisusb->lock));
 
 	/* Register device */
 	if ((retval = usb_register_dev(intf, &usb_sisusb_class))) {
@@ -3429,9 +3430,9 @@ static void sisusb_disconnect(struct usb
 	 * protect all other routines from the disconnect
 	 * case, not the other way round.
 	 */
-	down(&disconnect_sem);
+	mutex_lock(&disconnect_mutex);
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Wait for all URBs to complete and kill them in case (MUST do) */
 	if (!sisusb_wait_all_out_complete(sisusb))
@@ -3462,12 +3463,12 @@ static void sisusb_disconnect(struct usb
 	sisusb->present = 0;
 	sisusb->ready = 0;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	/* decrement our usage count */
 	kref_put(&sisusb->kref, sisusb_delete);
 
-	up(&disconnect_sem);
+	mutex_unlock(&disconnect_mutex);
 
 	printk(KERN_INFO "sisusbvga[%d]: Disconnected\n", minor);
 }
--- gregkh-2.6.orig/drivers/usb/misc/sisusbvga/sisusb.h
+++ gregkh-2.6/drivers/usb/misc/sisusbvga/sisusb.h
@@ -41,6 +41,8 @@
 #define SISUSB_NEW_CONFIG_COMPAT
 #endif
 
+#include <linux/mutex.h>
+
 /* For older kernels, support for text consoles is by default
  * off. To ensable text console support, change the following:
  */
@@ -116,7 +118,7 @@ struct sisusb_usb_data {
 	struct usb_interface *interface;
 	struct kref kref;
 	wait_queue_head_t wait_q;	/* for syncind and timeouts */
-	struct semaphore lock;		/* general race avoidance */
+	struct mutex lock;		/* general race avoidance */
 	unsigned int ifnum;		/* interface number of the USB device */
 	int minor;			/* minor (for logging clarity) */
 	int isopen;			/* !=0 if open */
--- gregkh-2.6.orig/drivers/usb/misc/sisusbvga/sisusb_con.c
+++ gregkh-2.6/drivers/usb/misc/sisusbvga/sisusb_con.c
@@ -48,6 +48,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/mutex.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
@@ -102,7 +103,7 @@ static struct sisusb_usb_data *mysisusbs
 /* Forward declaration */
 static const struct consw sisusb_con;
 
-extern struct semaphore disconnect_sem;
+extern struct mutex disconnect_mutex;
 
 static inline void
 sisusbcon_memsetw(u16 *s, u16 c, unsigned int count)
@@ -194,11 +195,11 @@ sisusb_get_sisusb_lock_and_check(unsigne
 	if (!(sisusb = sisusb_get_sisusb(console)))
 		return NULL;
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	if (!sisusb_sisusb_valid(sisusb) ||
 	    !sisusb->havethisconsole[console]) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return NULL;
 	}
 
@@ -236,18 +237,18 @@ sisusbcon_init(struct vc_data *c, int in
 	 * are set up/restored.
 	 */
 
-	down(&disconnect_sem);
+	mutex_lock(&disconnect_mutex);
 
 	if (!(sisusb = sisusb_get_sisusb(c->vc_num))) {
-		up(&disconnect_sem);
+		mutex_unlock(&disconnect_mutex);
 		return;
 	}
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	if (!sisusb_sisusb_valid(sisusb)) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		return;
 	}
 
@@ -284,9 +285,9 @@ sisusbcon_init(struct vc_data *c, int in
 	if (!*c->vc_uni_pagedir_loc)
 		con_set_default_unimap(c);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
-	up(&disconnect_sem);
+	mutex_unlock(&disconnect_mutex);
 
 	if (init) {
 		c->vc_cols = cols;
@@ -306,14 +307,14 @@ sisusbcon_deinit(struct vc_data *c)
 	 * and others, ie not under our control.
 	 */
 
-	down(&disconnect_sem);
+	mutex_lock(&disconnect_mutex);
 
 	if (!(sisusb = sisusb_get_sisusb(c->vc_num))) {
-		up(&disconnect_sem);
+		mutex_unlock(&disconnect_mutex);
 		return;
 	}
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Clear ourselves in mysisusbs */
 	mysisusbs[c->vc_num] = NULL;
@@ -332,12 +333,12 @@ sisusbcon_deinit(struct vc_data *c)
 		}
 	}
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	/* decrement the usage count on our sisusb */
 	kref_put(&sisusb->kref, sisusb_delete);
 
-	up(&disconnect_sem);
+	mutex_unlock(&disconnect_mutex);
 }
 
 /* interface routine */
@@ -417,7 +418,7 @@ sisusbcon_putc(struct vc_data *c, int ch
 #endif
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
@@ -425,7 +426,7 @@ sisusbcon_putc(struct vc_data *c, int ch
 	sisusb_copy_memory(sisusb, (char *)SISUSB_VADDR(x, y),
 				(u32)SISUSB_HADDR(x, y), 2, &written);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 }
 
 /* Interface routine */
@@ -453,14 +454,14 @@ sisusbcon_putcs(struct vc_data *c, const
 		sisusbcon_writew(sisusbcon_readw(s++), dest++);
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
 	sisusb_copy_memory(sisusb, (char *)SISUSB_VADDR(x, y),
 				(u32)SISUSB_HADDR(x, y), count * 2, &written);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 }
 
 /* Interface routine */
@@ -504,7 +505,7 @@ sisusbcon_clear(struct vc_data *c, int y
 	}
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
@@ -514,7 +515,7 @@ sisusbcon_clear(struct vc_data *c, int y
 	sisusb_copy_memory(sisusb, (unsigned char *)SISUSB_VADDR(x, y),
 				(u32)SISUSB_HADDR(x, y), length, &written);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 }
 
 /* Interface routine */
@@ -576,7 +577,7 @@ sisusbcon_bmove(struct vc_data *c, int s
 #endif
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
@@ -586,7 +587,7 @@ sisusbcon_bmove(struct vc_data *c, int s
 	sisusb_copy_memory(sisusb, (unsigned char *)SISUSB_VADDR(dx, dy),
 				(u32)SISUSB_HADDR(dx, dy), length, &written);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 }
 
 /* interface routine */
@@ -609,7 +610,7 @@ sisusbcon_switch(struct vc_data *c)
 
 	/* Don't write to screen if in gfx mode */
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return 0;
 	}
 
@@ -618,7 +619,7 @@ sisusbcon_switch(struct vc_data *c)
 	 * as origin.
 	 */
 	if (c->vc_origin == (unsigned long)c->vc_screenbuf) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		printk(KERN_DEBUG "sisusb: ASSERT ORIGIN != SCREENBUF!\n");
 		return 0;
 	}
@@ -635,7 +636,7 @@ sisusbcon_switch(struct vc_data *c)
 				(u32)SISUSB_HADDR(0, 0),
 				length, &written);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 0;
 }
@@ -657,7 +658,7 @@ sisusbcon_save_screen(struct vc_data *c)
 	/* sisusb->lock is down */
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
@@ -669,7 +670,7 @@ sisusbcon_save_screen(struct vc_data *c)
 	sisusbcon_memcpyw((u16 *)c->vc_screenbuf, (u16 *)c->vc_origin,
 								length);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 }
 
 /* interface routine */
@@ -690,7 +691,7 @@ sisusbcon_set_palette(struct vc_data *c,
 	/* sisusb->lock is down */
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return -EINVAL;
 	}
 
@@ -705,7 +706,7 @@ sisusbcon_set_palette(struct vc_data *c,
 			break;
 	}
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 0;
 }
@@ -728,7 +729,7 @@ sisusbcon_blank(struct vc_data *c, int b
 		sisusb->is_gfx = blank ? 1 : 0;
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return 0;
 	}
 
@@ -777,7 +778,7 @@ sisusbcon_blank(struct vc_data *c, int b
 			cr63  = 0x40;
 			break;
 		default:
-			up(&sisusb->lock);
+			mutex_unlock(&sisusb->lock);
 			return -EINVAL;
 		}
 
@@ -788,7 +789,7 @@ sisusbcon_blank(struct vc_data *c, int b
 
 	}
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return ret;
 }
@@ -809,7 +810,7 @@ sisusbcon_scrolldelta(struct vc_data *c,
 	/* sisusb->lock is down */
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return 0;
 	}
 
@@ -849,7 +850,7 @@ sisusbcon_scrolldelta(struct vc_data *c,
 
 	sisusbcon_set_start_address(sisusb, c);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 1;
 }
@@ -867,7 +868,7 @@ sisusbcon_cursor(struct vc_data *c, int 
 	/* sisusb->lock is down */
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
@@ -879,7 +880,7 @@ sisusbcon_cursor(struct vc_data *c, int 
 	if (mode == CM_ERASE) {
 		sisusb_setidxregor(sisusb, SISCR, 0x0a, 0x20);
 		sisusb->sisusb_cursor_size_to = -1;
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return;
 	}
 
@@ -919,7 +920,7 @@ sisusbcon_cursor(struct vc_data *c, int 
 		sisusb->sisusb_cursor_size_to   = to;
 	}
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 }
 
 static int
@@ -961,7 +962,7 @@ sisusbcon_scroll_area(struct vc_data *c,
 	sisusb_copy_memory(sisusb, (char *)SISUSB_VADDR(0, t),
 				(u32)SISUSB_HADDR(0, t), length, &written);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 1;
 }
@@ -994,7 +995,7 @@ sisusbcon_scroll(struct vc_data *c, int 
 	/* sisusb->lock is down */
 
 	if (sisusb_is_inactive(c, sisusb)) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return 0;
 	}
 
@@ -1084,7 +1085,7 @@ sisusbcon_scroll(struct vc_data *c, int 
 
 	c->vc_pos = c->vc_pos - oldorigin + c->vc_origin;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 1;
 }
@@ -1106,7 +1107,7 @@ sisusbcon_set_origin(struct vc_data *c)
 	/* sisusb->lock is down */
 
 	if (sisusb_is_inactive(c, sisusb) || sisusb->con_blanked) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return 0;
 	}
 
@@ -1116,7 +1117,7 @@ sisusbcon_set_origin(struct vc_data *c)
 
 	sisusb->con_rolled_over = 0;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 1;
 }
@@ -1133,7 +1134,7 @@ sisusbcon_resize(struct vc_data *c, unsi
 
 	fh = sisusb->current_font_height;
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	/* We are quite unflexible as regards resizing. The vt code
 	 * handles sizes where the line length isn't equal the pitch
@@ -1167,7 +1168,7 @@ sisusbcon_do_font_op(struct sisusb_usb_d
 
 	if ((slot != 0 && slot != 2) || !fh) {
 		if (uplock)
-			up(&sisusb->lock);
+			mutex_unlock(&sisusb->lock);
 		return -EINVAL;
 	}
 
@@ -1327,7 +1328,7 @@ sisusbcon_do_font_op(struct sisusb_usb_d
 	}
 
 	if (uplock)
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 
 	if (dorecalc && c) {
 		int i, rows = c->vc_scan_lines / fh;
@@ -1351,7 +1352,7 @@ sisusbcon_do_font_op(struct sisusb_usb_d
 
 font_op_error:
 	if (uplock)
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 
 	return -EIO;
 }
@@ -1417,19 +1418,19 @@ sisusbcon_font_get(struct vc_data *c, st
 	font->charcount = 256;
 
 	if (!font->data) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return 0;
 	}
 
 	if (!sisusb->font_backup) {
-		up(&sisusb->lock);
+		mutex_unlock(&sisusb->lock);
 		return -ENODEV;
 	}
 
 	/* Copy 256 chars only, like vgacon */
 	memcpy(font->data, sisusb->font_backup, 256 * 32);
 
-	up(&sisusb->lock);
+	mutex_unlock(&sisusb->lock);
 
 	return 0;
 }
@@ -1512,14 +1513,14 @@ sisusb_console_init(struct sisusb_usb_da
 {
 	int i, ret, minor = sisusb->minor;
 
-	down(&disconnect_sem);
+	mutex_lock(&disconnect_mutex);
 
-	down(&sisusb->lock);
+	mutex_lock(&sisusb->lock);
 
 	/* Erm.. that should not happen */
 	if (sisusb->haveconsole || !sisusb->SiS_Pr) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		return 1;
 	}
 
@@ -1529,15 +1530,15 @@ sisusb_console_init(struct sisusb_usb_da
 	if (first > last ||
 	    first > MAX_NR_CONSOLES ||
 	    last > MAX_NR_CONSOLES) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		return 1;
 	}
 
 	/* If gfxcore not initialized or no consoles given, quit graciously */
 	if (!sisusb->gfxinit || first < 1 || last < 1) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		return 0;
 	}
 
@@ -1547,8 +1548,8 @@ sisusb_console_init(struct sisusb_usb_da
 
 	/* Set up text mode (and upload  default font) */
 	if (sisusb_reset_text_mode(sisusb, 1)) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		printk(KERN_ERR
 			"sisusbvga[%d]: Failed to set up text mode\n",
 			minor);
@@ -1571,16 +1572,16 @@ sisusb_console_init(struct sisusb_usb_da
 
 	/* Allocate screen buffer */
 	if (!(sisusb->scrbuf = (unsigned long)vmalloc(sisusb->scrbuf_size))) {
-		up(&sisusb->lock);
-		up(&disconnect_sem);
+		mutex_unlock(&sisusb->lock);
+		mutex_unlock(&disconnect_mutex);
 		printk(KERN_ERR
 			"sisusbvga[%d]: Failed to allocate screen buffer\n",
 			minor);
 		return 1;
 	}
 
-	up(&sisusb->lock);
-	up(&disconnect_sem);
+	mutex_unlock(&sisusb->lock);
+	mutex_unlock(&disconnect_mutex);
 
 	/* Now grab the desired console(s) */
 	ret = take_over_console(&sisusb_con, first - 1, last - 1, 0);
