From stern@rowland.harvard.edu Wed Aug 30 12:47:40 2006
Date: Wed, 30 Aug 2006 15:47:31 -0400 (EDT)
From: Alan Stern <stern@rowland.harvard.edu>
To: Greg KH <greg@kroah.com>
cc: David Brownell <david-b@pacbell.net>, USB development list <linux-usb-devel@lists.sourceforge.net>
Subject: [PATCH 6/6] ehci-hcd: fix root-hub wakeup support
Message-ID: <Pine.LNX.4.44L0.0608301536420.5858-100000@iolanthe.rowland.org>

This patch (as738) fixes the root-hub remote-wakeup support in ehci-hcd.
The existing code has two problems.  First, when the bus is suspended
all root-hub interrupts are disabled.  Second, the call to
usb_hcd_resume_root_hub() is in the wrong place -- it is invoked when a
wakeup request arrives on a suspended port rather than when the root hub
itself generates a wakeup request.

Working remote-wakeup support is an important part of autoresume and a
prerequisite for autosuspend.


Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: David Brownell <david-b@pacbell.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/ehci-hcd.c |    3 +--
 drivers/usb/host/ehci-hub.c |    4 ++++
 2 files changed, 5 insertions(+), 2 deletions(-)

--- gregkh-2.6.orig/drivers/usb/host/ehci-hcd.c
+++ gregkh-2.6/drivers/usb/host/ehci-hcd.c
@@ -616,7 +616,7 @@ static irqreturn_t ehci_irq (struct usb_
 		/* resume root hub? */
 		status = readl (&ehci->regs->command);
 		if (!(status & CMD_RUN))
-			writel (status | CMD_RUN, &ehci->regs->command);
+			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
 			int pstatus = readl (&ehci->regs->port_status [i]);
@@ -633,7 +633,6 @@ static irqreturn_t ehci_irq (struct usb_
 			 */
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 
--- gregkh-2.6.orig/drivers/usb/host/ehci-hub.c
+++ gregkh-2.6/drivers/usb/host/ehci-hub.c
@@ -76,6 +76,10 @@ static int ehci_bus_suspend (struct usb_
 	ehci_halt (ehci);
 	hcd->state = HC_STATE_SUSPENDED;
 
+	/* allow remote wakeup */
+	if (device_may_wakeup(&hcd->self.root_hub->dev))
+		writel (INTR_MASK, &ehci->regs->intr_enable);
+
 	ehci->next_statechange = jiffies + msecs_to_jiffies(10);
 	spin_unlock_irq (&ehci->lock);
 	return 0;
