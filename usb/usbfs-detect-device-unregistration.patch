From stern@rowland.harvard.edu Sat Jul  1 19:06:01 2006
Date: Sat, 1 Jul 2006 22:05:56 -0400 (EDT)
From: Alan Stern <stern@rowland.harvard.edu>
To: Greg KH <greg@kroah.com>
Subject: [PATCH 02/15] usbfs: detect device unregistration
Message-ID: <Pine.LNX.4.44L0.0607012205020.2691-100000@mabel.localdomain>

This patch (as711b) is a revised version of an earlier submission.  It
modifies the usbfs code to detect when a device has been unregistered from
usbfs, even if the device is still connected.  Although this can't happen
now, it will be able to happen after the upcoming changes to usb_generic.

Nobody objected to this patch when it was submitted before, so it should
be okay to apply this version.  The revision is merely to take into
account the changes introduced by as723, which touches the same driver.


Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/usb/core/devio.c |   13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

--- gregkh-2.6.orig/drivers/usb/core/devio.c
+++ gregkh-2.6/drivers/usb/core/devio.c
@@ -90,9 +90,10 @@ MODULE_PARM_DESC (usbfs_snoop, "true to 
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
-static inline int connected (struct usb_device *dev)
+static inline int connected (struct dev_state *ps)
 {
-	return dev->state != USB_STATE_NOTATTACHED;
+	return (!list_empty(&ps->list) &&
+			ps->dev->state != USB_STATE_NOTATTACHED);
 }
 
 static loff_t usbdev_lseek(struct file *file, loff_t offset, int orig)
@@ -130,7 +131,7 @@ static ssize_t usbdev_read(struct file *
 
 	pos = *ppos;
 	usb_lock_device(dev);
-	if (!connected(dev)) {
+	if (!connected(ps)) {
 		ret = -ENODEV;
 		goto err;
 	} else if (pos < 0) {
@@ -1326,7 +1327,7 @@ static int proc_ioctl(struct dev_state *
 		}
 	}
 
-	if (!connected(ps->dev)) {
+	if (!connected(ps)) {
 		kfree(buf);
 		return -ENODEV;
 	}
@@ -1425,7 +1426,7 @@ static int usbdev_ioctl(struct inode *in
 	if (!(file->f_mode & FMODE_WRITE))
 		return -EPERM;
 	usb_lock_device(dev);
-	if (!connected(dev)) {
+	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
 	}
@@ -1566,7 +1567,7 @@ static unsigned int usbdev_poll(struct f
 	poll_wait(file, &ps->wait, wait);
 	if (file->f_mode & FMODE_WRITE && !list_empty(&ps->async_completed))
 		mask |= POLLOUT | POLLWRNORM;
-	if (!connected(ps->dev))
+	if (!connected(ps))
 		mask |= POLLERR | POLLHUP;
 	return mask;
 }
