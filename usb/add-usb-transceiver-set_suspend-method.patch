From david-b@pacbell.net Sun Oct 16 15:48:21 2005
Date: Sun, 16 Oct 2005 15:47:04 -0700
From: David Brownell <david-b@pacbell.net>
To: greg@kroah.com
Subject: [PATCH 2.6.15] add usb transceiver set_suspend() method
Cc: Juha Yrj?l? <juha.yrjola@nokia.com>
Message-Id: <20051016224704.66F0EBF906@adsl-69-107-32-110.dsl.pltn13.pacbell.net>

From: Juha Yrj?l? <juha.yrjola@nokia.com>

When a USB device is put into suspend mode, the current drawn from VBUS
has to be less than 500 uA. Some transceivers need to be put into a
special power-saving mode to accomplish this, and won't have a separate
OTG driver handling that.

This adds a suspend method to the "otg_transceiver" struct -- misnamed,
it's not only for OTG -- and calls it from the OMAP UDC driver.

Signed-off-by: Juha Yrj?l? <juha.yrjola@nokia.com>
Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/usb/gadget/omap_udc.c |    4 ++++
 include/linux/usb_otg.h       |   13 +++++++++++++
 2 files changed, 17 insertions(+)

--- gregkh-2.6.orig/include/linux/usb_otg.h
+++ gregkh-2.6/include/linux/usb_otg.h
@@ -63,6 +63,10 @@ struct otg_transceiver {
 	int	(*set_power)(struct otg_transceiver *otg,
 				unsigned mA);
 
+	/* for non-OTG B devices: set transceiver into suspend mode */
+	int	(*set_suspend)(struct otg_transceiver *otg,
+				int suspend);
+
 	/* for B devices only:  start session with A-Host */
 	int	(*start_srp)(struct otg_transceiver *otg);
 
@@ -108,6 +112,15 @@ otg_set_power(struct otg_transceiver *ot
 }
 
 static inline int
+otg_set_suspend(struct otg_transceiver *otg, int suspend)
+{
+	if (otg->set_suspend != NULL)
+		return otg->set_suspend(otg, suspend);
+	else
+		return 0;
+}
+
+static inline int
 otg_start_srp(struct otg_transceiver *otg)
 {
 	return otg->start_srp(otg);
--- gregkh-2.6.orig/drivers/usb/gadget/omap_udc.c
+++ gregkh-2.6/drivers/usb/gadget/omap_udc.c
@@ -1788,8 +1788,12 @@ static void devstate_irq(struct omap_udc
 					udc->driver->suspend(&udc->gadget);
 					spin_lock(&udc->lock);
 				}
+				if (udc->transceiver)
+					otg_set_suspend(udc->transceiver, 1);
 			} else {
 				VDBG("resume\n");
+				if (udc->transceiver)
+					otg_set_suspend(udc->transceiver, 0);
 				if (udc->gadget.speed == USB_SPEED_FULL
 						&& udc->driver->resume) {
 					spin_unlock(&udc->lock);
