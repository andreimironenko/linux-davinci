From stern@rowland.harvard.edu Fri May  5 13:27:08 2006
Date: Fri, 5 May 2006 16:26:58 -0400 (EDT)
From: Alan Stern <stern@rowland.harvard.edu>
To: Greg KH <greg@kroah.com>
Subject: USB: UHCI: store the endpoint type in the QH structure
Message-ID: <Pine.LNX.4.44L0.0605051623430.5854-100000@iolanthe.rowland.org>

This patch (as675) simplifies uhci-hcd slightly by storing each endpoint's
type in the corresponding Queue Header structure.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/uhci-debug.c |   26 +++++++++++++++++++-------
 drivers/usb/host/uhci-hcd.h   |    1 +
 drivers/usb/host/uhci-q.c     |   34 ++++++++++++++++++----------------
 3 files changed, 38 insertions(+), 23 deletions(-)

--- gregkh-2.6.orig/drivers/usb/host/uhci-debug.c
+++ gregkh-2.6/drivers/usb/host/uhci-debug.c
@@ -98,6 +98,7 @@ static int uhci_show_urbp(struct urb_pri
 	char *out = buf;
 	struct uhci_td *td;
 	int i, nactive, ninactive;
+	char *ptype;
 
 	if (len < 200)
 		return 0;
@@ -110,13 +111,14 @@ static int uhci_show_urbp(struct urb_pri
 			(usb_pipein(urbp->urb->pipe) ? "IN" : "OUT"));
 
 	switch (usb_pipetype(urbp->urb->pipe)) {
-	case PIPE_ISOCHRONOUS: out += sprintf(out, "ISO"); break;
-	case PIPE_INTERRUPT: out += sprintf(out, "INT"); break;
-	case PIPE_BULK: out += sprintf(out, "BLK"); break;
-	case PIPE_CONTROL: out += sprintf(out, "CTL"); break;
+	case PIPE_ISOCHRONOUS: ptype = "ISO"; break;
+	case PIPE_INTERRUPT: ptype = "INT"; break;
+	case PIPE_BULK: ptype = "BLK"; break;
+	default:
+	case PIPE_CONTROL: ptype = "CTL"; break;
 	}
 
-	out += sprintf(out, "%s", (urbp->fsbr ? " FSBR" : ""));
+	out += sprintf(out, "%s%s", ptype, (urbp->fsbr ? " FSBR" : ""));
 
 	if (urbp->urb->status != -EINPROGRESS)
 		out += sprintf(out, " Status=%d", urbp->urb->status);
@@ -147,13 +149,23 @@ static int uhci_show_qh(struct uhci_qh *
 	char *out = buf;
 	int i, nurbs;
 	__le32 element = qh_element(qh);
+	char *qtype;
 
 	/* Try to make sure there's enough memory */
 	if (len < 80 * 6)
 		return 0;
 
-	out += sprintf(out, "%*s[%p] link (%08x) element (%08x)\n", space, "",
-			qh, le32_to_cpu(qh->link), le32_to_cpu(element));
+	switch (qh->type) {
+	case USB_ENDPOINT_XFER_ISOC: qtype = "ISO"; break;
+	case USB_ENDPOINT_XFER_INT: qtype = "INT"; break;
+	case USB_ENDPOINT_XFER_BULK: qtype = "BLK"; break;
+	case USB_ENDPOINT_XFER_CONTROL: qtype = "CTL"; break;
+	default: qtype = "Skel" ; break;
+	}
+
+	out += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",
+			space, "", qh, qtype,
+			le32_to_cpu(qh->link), le32_to_cpu(element));
 
 	if (element & UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
--- gregkh-2.6.orig/drivers/usb/host/uhci-hcd.h
+++ gregkh-2.6/drivers/usb/host/uhci-hcd.h
@@ -132,6 +132,7 @@ struct uhci_qh {
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
+	int type;			/* Queue type (control, bulk, etc) */
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
--- gregkh-2.6.orig/drivers/usb/host/uhci-q.c
+++ gregkh-2.6/drivers/usb/host/uhci-q.c
@@ -179,10 +179,12 @@ static struct uhci_qh *uhci_alloc_qh(str
 		qh->hep = hep;
 		qh->udev = udev;
 		hep->hcpriv = qh;
+		qh->type = hep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
 	} else {		/* Skeleton QH */
 		qh->state = QH_STATE_ACTIVE;
 		qh->udev = NULL;
+		qh->type = -1;
 	}
 	return qh;
 }
@@ -217,8 +219,8 @@ static void uhci_save_toggle(struct uhci
 	qh->element = UHCI_PTR_TERM;
 
 	/* Only bulk and interrupt pipes have to worry about toggles */
-	if (!(usb_pipetype(urb->pipe) == PIPE_BULK ||
-			usb_pipetype(urb->pipe) == PIPE_INTERRUPT))
+	if (!(qh->type == USB_ENDPOINT_XFER_BULK ||
+			qh->type == USB_ENDPOINT_XFER_INT))
 		return;
 
 	/* Find the first active TD; that's the device's toggle state */
@@ -1099,14 +1101,14 @@ static int uhci_urb_enqueue(struct usb_h
 	}
 	urbp->qh = qh;
 
-	switch (usb_pipetype(urb->pipe)) {
-	case PIPE_CONTROL:
+	switch (qh->type) {
+	case USB_ENDPOINT_XFER_CONTROL:
 		ret = uhci_submit_control(uhci, urb, qh);
 		break;
-	case PIPE_BULK:
+	case USB_ENDPOINT_XFER_BULK:
 		ret = uhci_submit_bulk(uhci, urb, qh);
 		break;
-	case PIPE_INTERRUPT:
+	case USB_ENDPOINT_XFER_INT:
 		if (list_empty(&qh->queue)) {
 			bustime = usb_check_bandwidth(urb->dev, urb);
 			if (bustime < 0)
@@ -1125,7 +1127,7 @@ static int uhci_urb_enqueue(struct usb_h
 			ret = uhci_submit_interrupt(uhci, urb, qh);
 		}
 		break;
-	case PIPE_ISOCHRONOUS:
+	case USB_ENDPOINT_XFER_ISOC:
 		bustime = usb_check_bandwidth(urb->dev, urb);
 		if (bustime < 0) {
 			ret = bustime;
@@ -1175,7 +1177,7 @@ static int uhci_urb_dequeue(struct usb_h
 		goto done;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
-	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
+	if (urbp->qh->type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 	uhci_unlink_qh(uhci, urbp->qh);
 
@@ -1195,7 +1197,7 @@ __acquires(uhci->lock)
 	struct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;
 
 	/* Isochronous TDs get unlinked directly from the frame list */
-	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
+	if (qh->type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 
 	/* If the URB isn't first on its queue, adjust the link pointer
@@ -1224,13 +1226,13 @@ __acquires(uhci->lock)
 	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
 	uhci_free_urb_priv(uhci, urbp);
 
-	switch (usb_pipetype(urb->pipe)) {
-	case PIPE_ISOCHRONOUS:
+	switch (qh->type) {
+	case USB_ENDPOINT_XFER_ISOC:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		if (urb->bandwidth)
 			usb_release_bandwidth(urb->dev, urb, 1);
 		break;
-	case PIPE_INTERRUPT:
+	case USB_ENDPOINT_XFER_INT:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		/* Make sure we don't release if we have a queued URB */
 		if (list_empty(&qh->queue) && urb->bandwidth)
@@ -1273,14 +1275,14 @@ static void uhci_scan_qh(struct uhci_hcd
 		urbp = list_entry(qh->queue.next, struct urb_priv, node);
 		urb = urbp->urb;
 
-		switch (usb_pipetype(urb->pipe)) {
-		case PIPE_CONTROL:
+		switch (qh->type) {
+		case USB_ENDPOINT_XFER_CONTROL:
 			status = uhci_result_control(uhci, urb);
 			break;
-		case PIPE_ISOCHRONOUS:
+		case USB_ENDPOINT_XFER_ISOC:
 			status = uhci_result_isochronous(uhci, urb);
 			break;
-		default:	/* PIPE_BULK or PIPE_INTERRUPT */
+		default:	/* USB_ENDPOINT_XFER_BULK or _INT */
 			status = uhci_result_common(uhci, urb);
 			break;
 		}
