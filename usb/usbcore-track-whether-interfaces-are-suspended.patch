From stern@rowland.harvard.edu Sat Jul  1 19:11:49 2006
Date: Sat, 1 Jul 2006 22:11:44 -0400 (EDT)
From: Alan Stern <stern@rowland.harvard.edu>
To: Greg KH <greg@kroah.com>
Subject: [PATCH 10/15] usbcore: track whether interfaces are suspended
Message-ID: <Pine.LNX.4.44L0.0607012211030.2691-100000@mabel.localdomain>

Currently we rely on intf->dev.power.power_state.event for tracking
whether intf is suspended.  This is not a reliable technique because
that value is owned by the PM core, not by usbcore.  This patch (as718b)
adds a new flag so that we can accurately tell which interfaces are
suspended and which aren't.

At first one might think these flags aren't needed, since interfaces
will be suspended along with their devices.  It turns out there are a
couple of intermediate situations where that's not quite true, such as
while processing a remote-wakeup request.


Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/usb.h |    6 +++---
 include/linux/usb.h    |    3 +++
 2 files changed, 6 insertions(+), 3 deletions(-)

--- gregkh-2.6.orig/drivers/usb/core/usb.h
+++ gregkh-2.6/drivers/usb/core/usb.h
@@ -59,17 +59,17 @@ static inline int is_usb_device_driver(s
 
 static inline void mark_active(struct usb_interface *f)
 {
-	f->dev.power.power_state.event = PM_EVENT_ON;
+	f->is_active = 1;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
-	f->dev.power.power_state.event = PM_EVENT_FREEZE;
+	f->is_active = 0;
 }
 
 static inline int is_active(struct usb_interface *f)
 {
-	return f->dev.power.power_state.event == PM_EVENT_ON;
+	return f->is_active;
 }
 
 
--- gregkh-2.6.orig/include/linux/usb.h
+++ gregkh-2.6/include/linux/usb.h
@@ -102,6 +102,7 @@ enum usb_interface_condition {
  *	number from the USB core by calling usb_register_dev().
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
+ * @is_active: flag set when the interface is bound and not suspended.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
  *
@@ -142,6 +143,8 @@ struct usb_interface {
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
+	unsigned is_active:1;		/* the interface is not suspended */
+
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
 };
