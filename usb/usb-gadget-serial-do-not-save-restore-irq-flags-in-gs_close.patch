From vagabon.xyz@gmail.com Wed Jun 14 01:47:35 2006
Message-ID: <cda58cb80606140147v76b3198jaad106a8121952b2@mail.gmail.com>
Date: Wed, 14 Jun 2006 10:47:18 +0200
From: "Franck Bui-Huu" <vagabon.xyz@gmail.com>
To: "David Brownell" <david-b@pacbell.net>
Subject: USB: gadget-serial: do not save/restore IRQ flags in gs_close()
Cc: "Greg KH" <greg@kroah.com>, "Alan Stern" <stern@rowland.harvard.edu>, <alborchers@steinerpoint.com>
Content-Disposition: inline

As pointed out by David Brownell, we know that IRQs are never
blocked when calling gs_close function. So the save/restore
IRQ flags are pointless.

Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/serial.c |   17 ++++++++---------
 1 file changed, 8 insertions(+), 9 deletions(-)

--- gregkh-2.6.orig/drivers/usb/gadget/serial.c
+++ gregkh-2.6/drivers/usb/gadget/serial.c
@@ -53,8 +53,8 @@
 
 /* Defines */
 
-#define GS_VERSION_STR			"v2.1"
-#define GS_VERSION_NUM			0x0201
+#define GS_VERSION_STR			"v2.2"
+#define GS_VERSION_NUM			0x0202
 
 #define GS_LONG_NAME			"Gadget Serial"
 #define GS_SHORT_NAME			"g_serial"
@@ -774,12 +774,11 @@ exit_unlock_dev:
 
 #define GS_WRITE_FINISHED_EVENT_SAFELY(p)			\
 ({								\
-	unsigned long flags;					\
 	int cond;						\
 								\
-	spin_lock_irqsave(&(p)->port_lock, flags);		\
+	spin_lock_irq(&(p)->port_lock);				\
 	cond = !(p)->port_dev || !gs_buf_data_avail((p)->port_write_buf); \
-	spin_unlock_irqrestore(&(p)->port_lock, flags);		\
+	spin_unlock_irq(&(p)->port_lock);			\
 	cond;							\
 })
 
@@ -799,7 +798,7 @@ static void gs_close(struct tty_struct *
 	sem = &gs_open_close_sem[port->port_num];
 	down(sem);
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	spin_lock_irq(&port->port_lock);
 
 	if (port->port_open_count == 0) {
 		printk(KERN_ERR
@@ -827,11 +826,11 @@ static void gs_close(struct tty_struct *
 	/* wait for write buffer to drain, or */
 	/* at most GS_CLOSE_TIMEOUT seconds */
 	if (gs_buf_data_avail(port->port_write_buf) > 0) {
-		spin_unlock_irqrestore(&port->port_lock, flags);
+		spin_unlock_irq(&port->port_lock);
 		wait_event_interruptible_timeout(port->port_write_wait,
 					GS_WRITE_FINISHED_EVENT_SAFELY(port),
 					GS_CLOSE_TIMEOUT * HZ);
-		spin_lock_irqsave(&port->port_lock, flags);
+		spin_lock_irq(&port->port_lock);
 	}
 
 	/* free disconnected port on final close */
@@ -851,7 +850,7 @@ static void gs_close(struct tty_struct *
 		port->port_num, tty, file);
 
 exit:
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	spin_unlock_irq(&port->port_lock);
 	up(sem);
 }
 
