 drivers/base/class.c   |  104 +++++++++++++++++++++++++++++++++++--------------
 drivers/usb/gregkh.c   |   20 ++++++++-
 include/linux/device.h |    6 ++
 3 files changed, 100 insertions(+), 30 deletions(-)

--- gregkh-2.6.orig/drivers/base/class.c	2005-09-27 03:06:14.000000000 -0700
+++ gregkh-2.6/drivers/base/class.c	2005-09-27 17:04:45.000000000 -0700
@@ -100,7 +100,8 @@
 
 void class_put(struct class * cls)
 {
-	subsys_put(&cls->subsys);
+	if (cls)
+		subsys_put(&cls->subsys);
 }
 
 
@@ -477,31 +478,36 @@
 
 int class_device_add(struct class_device *class_dev)
 {
-	struct class * parent = NULL;
-	struct class_interface * class_intf;
+	struct class *parent_class = NULL;
+	struct class_device *parent_class_dev = NULL;
+	struct class_interface *class_intf;
 	char *class_name = NULL;
-	int error;
+	int error = -EINVAL;
 
 	class_dev = class_device_get(class_dev);
 	if (!class_dev)
 		return -EINVAL;
 
-	if (!strlen(class_dev->class_id)) {
-		error = -EINVAL;
+	if (!strlen(class_dev->class_id))
 		goto register_done;
-	}
 
-	parent = class_get(class_dev->class);
+	parent_class = class_get(class_dev->class);
+	if (!parent_class)
+		goto register_done;
+	parent_class_dev = class_device_get(class_dev->parent);
 
 	pr_debug("CLASS: registering class device: ID = '%s'\n",
 		 class_dev->class_id);
 
 	/* first, register with generic layer. */
 	kobject_set_name(&class_dev->kobj, "%s", class_dev->class_id);
-	if (parent)
-		class_dev->kobj.parent = &parent->subsys.kset.kobj;
+	if (parent_class_dev)
+		class_dev->kobj.parent = &parent_class_dev->kobj;
+	else
+		class_dev->kobj.parent = &parent_class->subsys.kset.kobj;
 
-	if ((error = kobject_add(&class_dev->kobj)))
+	error = kobject_add(&class_dev->kobj);
+	if (error)
 		goto register_done;
 
 	/* add the needed attributes to this device */
@@ -516,7 +522,7 @@
 
 		attr->attr.name = "dev";
 		attr->attr.mode = S_IRUGO;
-		attr->attr.owner = parent->owner;
+		attr->attr.owner = parent_class->owner;
 		attr->show = show_dev;
 		attr->store = NULL;
 		class_device_create_file(class_dev, attr);
@@ -531,7 +537,7 @@
 		memset(attr, sizeof(*attr), 0x00);
 		attr->attr.name = "sample.sh";
 		attr->attr.mode = S_IRUSR | S_IXUSR | S_IRUGO;
-		attr->attr.owner = parent->owner;
+		attr->attr.owner = parent_class->owner;
 		attr->show = show_sample;
 		attr->store = NULL;
 		class_device_create_file(class_dev, attr);
@@ -552,18 +558,20 @@
 	kobject_hotplug(&class_dev->kobj, KOBJ_ADD);
 
 	/* notify any interfaces this device is now here */
-	if (parent) {
-		down(&parent->sem);
-		list_add_tail(&class_dev->node, &parent->children);
-		list_for_each_entry(class_intf, &parent->interfaces, node)
+	if (parent_class) {
+		down(&parent_class->sem);
+		list_add_tail(&class_dev->node, &parent_class->children);
+		list_for_each_entry(class_intf, &parent_class->interfaces, node)
 			if (class_intf->add)
 				class_intf->add(class_dev, class_intf);
-		up(&parent->sem);
+		up(&parent_class->sem);
 	}
 
  register_done:
-	if (error && parent)
-		class_put(parent);
+	if (error) {
+		class_put(parent_class);
+		class_device_put(parent_class_dev);
+	}
 	class_device_put(class_dev);
 	kfree(class_name);
 	return error;
@@ -626,19 +634,56 @@
 	return ERR_PTR(retval);
 }
 
+struct class_device *class_device_create_child(struct class *cls, struct class_device *parent, dev_t devt,
+					 struct device *device, char *fmt, ...)
+{
+	va_list args;
+	struct class_device *class_dev = NULL;
+	int retval = -ENODEV;
+
+	if (cls == NULL || IS_ERR(cls))
+		goto error;
+
+	class_dev = kzalloc(sizeof(*class_dev), GFP_KERNEL);
+	if (!class_dev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	class_dev->devt = devt;
+	class_dev->dev = device;
+	class_dev->class = cls;
+	class_dev->parent = parent;
+
+	va_start(args, fmt);
+	vsnprintf(class_dev->class_id, BUS_ID_SIZE, fmt, args);
+	va_end(args);
+	retval = class_device_register(class_dev);
+	if (retval)
+		goto error;
+
+	return class_dev;
+
+error:
+	kfree(class_dev);
+	return ERR_PTR(retval);
+}
+EXPORT_SYMBOL_GPL(class_device_create_child);
+
 void class_device_del(struct class_device *class_dev)
 {
-	struct class * parent = class_dev->class;
-	struct class_interface * class_intf;
+	struct class *parent_class = class_dev->class;
+	struct class_device *parent_device = class_dev->parent;
+	struct class_interface *class_intf;
 	char *class_name = NULL;
 
-	if (parent) {
-		down(&parent->sem);
+	if (parent_class) {
+		down(&parent_class->sem);
 		list_del_init(&class_dev->node);
-		list_for_each_entry(class_intf, &parent->interfaces, node)
+		list_for_each_entry(class_intf, &parent_class->interfaces, node)
 			if (class_intf->remove)
 				class_intf->remove(class_dev, class_intf);
-		up(&parent->sem);
+		up(&parent_class->sem);
 	}
 
 	if (class_dev->dev) {
@@ -655,8 +700,8 @@
 	kobject_hotplug(&class_dev->kobj, KOBJ_REMOVE);
 	kobject_del(&class_dev->kobj);
 
-	if (parent)
-		class_put(parent);
+	class_device_put(parent_device);
+	class_put(parent_class);
 	kfree(class_name);
 }
 
@@ -736,7 +781,8 @@
 
 void class_device_put(struct class_device *class_dev)
 {
-	kobject_put(&class_dev->kobj);
+	if (class_dev)
+		kobject_put(&class_dev->kobj);
 }
 
 
--- gregkh-2.6.orig/drivers/usb/gregkh.c	2005-09-27 03:06:14.000000000 -0700
+++ gregkh-2.6/drivers/usb/gregkh.c	2005-09-27 07:39:32.000000000 -0700
@@ -208,17 +208,35 @@
 
 static struct class *greg_class;
 
+
+ssize_t cd_show(struct class_device *cd, char *buf)
+{
+	return sprintf(buf, "this is device %s\n", kobject_name(&cd->kobj));
+}
+static CLASS_DEVICE_ATTR(name, 0444, cd_show, NULL);
+
+
+
 static void greg_class_init(void)
 {
+	struct class_device *g2;
+	struct class_device *cd;
+
 	greg_class = class_create(THIS_MODULE, "gregkh");
 
 	class_device_create(greg_class, MKDEV(42, 0), NULL, "greg1");
-	class_device_create(greg_class, MKDEV(42, 1), NULL, "greg2");
+	g2 = class_device_create(greg_class, MKDEV(42, 1), NULL, "greg2");
 	class_device_create(greg_class, MKDEV(42, 2), NULL, "greg3");
 
 	printk("GREG: create a dupe name\n");
 	class_device_create(greg_class, MKDEV(42, 3), NULL, "greg1");
 	printk("GREG: dup name created\n");
+
+	class_device_create_child(greg_class, g2, MKDEV(42,4), NULL, "greg2.4");
+	class_device_create_child(greg_class, g2, 0, NULL, "greg2.%s", "null");
+	cd = class_device_create_child(greg_class, g2, MKDEV(42,5), NULL, "greg%d.%d", 2, 5);
+	class_device_create_file(cd, &class_device_attr_name);
+
 }
 
 
--- gregkh-2.6.orig/include/linux/device.h	2005-09-27 03:06:14.000000000 -0700
+++ gregkh-2.6/include/linux/device.h	2005-09-27 16:24:45.000000000 -0700
@@ -201,6 +201,7 @@
 	struct class_device_attribute *sample_attr;
 	struct device		* dev;		/* not necessary, but nice to have */
 	void			* class_data;	/* class-specific data */
+	struct class_device	*parent;	/* parent of this child device, if there is one */
 
 	char	class_id[BUS_ID_SIZE];	/* unique to this class */
 };
@@ -264,6 +265,11 @@
 extern struct class_device *class_device_create(struct class *cls, dev_t devt,
 						struct device *device, char *fmt, ...)
 					__attribute__((format(printf,4,5)));
+extern struct class_device *class_device_create_child(struct class *cls,
+						struct class_device *parent,
+						dev_t devt, struct device *device,
+						char *fmt, ...)
+					__attribute__((format(printf,5,6)));
 extern void class_device_destroy(struct class *cls, dev_t devt);
 
 
