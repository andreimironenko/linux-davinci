 drivers/base/class.c   |   86 +++++++++++++++++++++++++++++--------------------
 drivers/usb/gregkh.c   |   26 ++++++++++++--
 include/linux/device.h |   10 +++--
 3 files changed, 81 insertions(+), 41 deletions(-)

--- gregkh-2.6.orig/drivers/base/class.c	2005-09-27 03:06:14.000000000 -0700
+++ gregkh-2.6/drivers/base/class.c	2005-09-28 12:26:32.000000000 -0700
@@ -100,7 +100,8 @@
 
 void class_put(struct class * cls)
 {
-	subsys_put(&cls->subsys);
+	if (cls)
+		subsys_put(&cls->subsys);
 }
 
 
@@ -477,31 +478,36 @@
 
 int class_device_add(struct class_device *class_dev)
 {
-	struct class * parent = NULL;
-	struct class_interface * class_intf;
+	struct class *parent_class = NULL;
+	struct class_device *parent_class_dev = NULL;
+	struct class_interface *class_intf;
 	char *class_name = NULL;
-	int error;
+	int error = -EINVAL;
 
 	class_dev = class_device_get(class_dev);
 	if (!class_dev)
 		return -EINVAL;
 
-	if (!strlen(class_dev->class_id)) {
-		error = -EINVAL;
+	if (!strlen(class_dev->class_id))
 		goto register_done;
-	}
 
-	parent = class_get(class_dev->class);
+	parent_class = class_get(class_dev->class);
+	if (!parent_class)
+		goto register_done;
+	parent_class_dev = class_device_get(class_dev->parent);
 
 	pr_debug("CLASS: registering class device: ID = '%s'\n",
 		 class_dev->class_id);
 
 	/* first, register with generic layer. */
 	kobject_set_name(&class_dev->kobj, "%s", class_dev->class_id);
-	if (parent)
-		class_dev->kobj.parent = &parent->subsys.kset.kobj;
+	if (parent_class_dev)
+		class_dev->kobj.parent = &parent_class_dev->kobj;
+	else
+		class_dev->kobj.parent = &parent_class->subsys.kset.kobj;
 
-	if ((error = kobject_add(&class_dev->kobj)))
+	error = kobject_add(&class_dev->kobj);
+	if (error)
 		goto register_done;
 
 	/* add the needed attributes to this device */
@@ -516,7 +522,7 @@
 
 		attr->attr.name = "dev";
 		attr->attr.mode = S_IRUGO;
-		attr->attr.owner = parent->owner;
+		attr->attr.owner = parent_class->owner;
 		attr->show = show_dev;
 		attr->store = NULL;
 		class_device_create_file(class_dev, attr);
@@ -531,7 +537,7 @@
 		memset(attr, sizeof(*attr), 0x00);
 		attr->attr.name = "sample.sh";
 		attr->attr.mode = S_IRUSR | S_IXUSR | S_IRUGO;
-		attr->attr.owner = parent->owner;
+		attr->attr.owner = parent_class->owner;
 		attr->show = show_sample;
 		attr->store = NULL;
 		class_device_create_file(class_dev, attr);
@@ -552,18 +558,20 @@
 	kobject_hotplug(&class_dev->kobj, KOBJ_ADD);
 
 	/* notify any interfaces this device is now here */
-	if (parent) {
-		down(&parent->sem);
-		list_add_tail(&class_dev->node, &parent->children);
-		list_for_each_entry(class_intf, &parent->interfaces, node)
+	if (parent_class) {
+		down(&parent_class->sem);
+		list_add_tail(&class_dev->node, &parent_class->children);
+		list_for_each_entry(class_intf, &parent_class->interfaces, node)
 			if (class_intf->add)
 				class_intf->add(class_dev, class_intf);
-		up(&parent->sem);
+		up(&parent_class->sem);
 	}
 
  register_done:
-	if (error && parent)
-		class_put(parent);
+	if (error) {
+		class_put(parent_class);
+		class_device_put(parent_class_dev);
+	}
 	class_device_put(class_dev);
 	kfree(class_name);
 	return error;
@@ -578,21 +586,28 @@
 /**
  * class_device_create - creates a class device and registers it with sysfs
  * @cs: pointer to the struct class that this device should be registered to.
+ * @parent: pointer to the parent struct class_device of this new device, if any.
  * @dev: the dev_t for the char device to be added.
  * @device: a pointer to a struct device that is assiociated with this class device.
  * @fmt: string for the class device's name
  *
  * This function can be used by char device classes.  A struct
  * class_device will be created in sysfs, registered to the specified
- * class.  A "dev" file will be created, showing the dev_t for the
- * device.  The pointer to the struct class_device will be returned from
- * the call.  Any further sysfs files that might be required can be
- * created using this pointer.
+ * class.
+ * A "dev" file will be created, showing the dev_t for the device, if
+ * the dev_t is not 0,0.
+ * If a pointer to a parent struct class_device is passed in, the newly
+ * created struct class_device will be a child of that device in sysfs.
+ * The pointer to the struct class_device will be returned from the
+ * call.  Any further sysfs files that might be required can be created
+ * using this pointer.
  *
  * Note: the struct class passed to this function must have previously
  * been created with a call to class_create().
  */
-struct class_device *class_device_create(struct class *cls, dev_t devt,
+struct class_device *class_device_create(struct class *cls,
+					 struct class_device *parent,
+					 dev_t devt,
 					 struct device *device, char *fmt, ...)
 {
 	va_list args;
@@ -611,6 +626,7 @@
 	class_dev->devt = devt;
 	class_dev->dev = device;
 	class_dev->class = cls;
+	class_dev->parent = parent;
 
 	va_start(args, fmt);
 	vsnprintf(class_dev->class_id, BUS_ID_SIZE, fmt, args);
@@ -628,17 +644,18 @@
 
 void class_device_del(struct class_device *class_dev)
 {
-	struct class * parent = class_dev->class;
-	struct class_interface * class_intf;
+	struct class *parent_class = class_dev->class;
+	struct class_device *parent_device = class_dev->parent;
+	struct class_interface *class_intf;
 	char *class_name = NULL;
 
-	if (parent) {
-		down(&parent->sem);
+	if (parent_class) {
+		down(&parent_class->sem);
 		list_del_init(&class_dev->node);
-		list_for_each_entry(class_intf, &parent->interfaces, node)
+		list_for_each_entry(class_intf, &parent_class->interfaces, node)
 			if (class_intf->remove)
 				class_intf->remove(class_dev, class_intf);
-		up(&parent->sem);
+		up(&parent_class->sem);
 	}
 
 	if (class_dev->dev) {
@@ -655,8 +672,8 @@
 	kobject_hotplug(&class_dev->kobj, KOBJ_REMOVE);
 	kobject_del(&class_dev->kobj);
 
-	if (parent)
-		class_put(parent);
+	class_device_put(parent_device);
+	class_put(parent_class);
 	kfree(class_name);
 }
 
@@ -736,7 +753,8 @@
 
 void class_device_put(struct class_device *class_dev)
 {
-	kobject_put(&class_dev->kobj);
+	if (class_dev)
+		kobject_put(&class_dev->kobj);
 }
 
 
--- gregkh-2.6.orig/drivers/usb/gregkh.c	2005-09-27 03:06:14.000000000 -0700
+++ gregkh-2.6/drivers/usb/gregkh.c	2005-09-28 12:40:17.000000000 -0700
@@ -208,17 +208,35 @@
 
 static struct class *greg_class;
 
+
+ssize_t cd_show(struct class_device *cd, char *buf)
+{
+	return sprintf(buf, "this is device %s\n", kobject_name(&cd->kobj));
+}
+static CLASS_DEVICE_ATTR(name, 0444, cd_show, NULL);
+
+
+
 static void greg_class_init(void)
 {
+	struct class_device *g2;
+	struct class_device *cd;
+
 	greg_class = class_create(THIS_MODULE, "gregkh");
 
-	class_device_create(greg_class, MKDEV(42, 0), NULL, "greg1");
-	class_device_create(greg_class, MKDEV(42, 1), NULL, "greg2");
-	class_device_create(greg_class, MKDEV(42, 2), NULL, "greg3");
+	class_device_create(greg_class, NULL, MKDEV(42, 0), NULL, "greg1");
+	g2 = class_device_create(greg_class, NULL, MKDEV(42, 1), NULL, "greg2");
+	class_device_create(greg_class, NULL, MKDEV(42, 2), NULL, "greg3");
 
 	printk("GREG: create a dupe name\n");
-	class_device_create(greg_class, MKDEV(42, 3), NULL, "greg1");
+	class_device_create(greg_class, NULL, MKDEV(42, 3), NULL, "greg1");
 	printk("GREG: dup name created\n");
+
+	class_device_create(greg_class, g2, MKDEV(42,4), NULL, "greg2.4");
+	class_device_create(greg_class, g2, 0, NULL, "greg2.%s", "null");
+	cd = class_device_create(greg_class, g2, MKDEV(42,5), NULL, "greg%d.%d", 2, 5);
+	class_device_create_file(cd, &class_device_attr_name);
+
 }
 
 
--- gregkh-2.6.orig/include/linux/device.h	2005-09-27 03:06:14.000000000 -0700
+++ gregkh-2.6/include/linux/device.h	2005-09-28 12:28:15.000000000 -0700
@@ -201,6 +201,7 @@
 	struct class_device_attribute *sample_attr;
 	struct device		* dev;		/* not necessary, but nice to have */
 	void			* class_data;	/* class-specific data */
+	struct class_device	*parent;	/* parent of this child device, if there is one */
 
 	char	class_id[BUS_ID_SIZE];	/* unique to this class */
 };
@@ -261,9 +262,12 @@
 
 extern struct class *class_create(struct module *owner, char *name);
 extern void class_destroy(struct class *cls);
-extern struct class_device *class_device_create(struct class *cls, dev_t devt,
-						struct device *device, char *fmt, ...)
-					__attribute__((format(printf,4,5)));
+extern struct class_device *class_device_create(struct class *cls,
+						struct class_device *parent,
+						dev_t devt,
+						struct device *device,
+						char *fmt, ...)
+					__attribute__((format(printf,5,6)));
 extern void class_device_destroy(struct class *cls, dev_t devt);
 
 
