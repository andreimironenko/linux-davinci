---
 drivers/base/Makefile  |    3 -
 drivers/base/base.h    |    1 
 drivers/base/core.c    |   11 +++
 drivers/base/virtual.c |  142 +++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/device.h |    1 
 5 files changed, 155 insertions(+), 3 deletions(-)

--- gregkh-2.6.orig/drivers/base/Makefile
+++ gregkh-2.6/drivers/base/Makefile
@@ -3,7 +3,8 @@
 obj-y			:= core.o sys.o bus.o dd.o \
 			   driver.o class.o platform.o \
 			   cpu.o firmware.o init.o map.o dmapool.o \
-			   attribute_container.o transport_class.o
+			   attribute_container.o transport_class.o \
+			   virtual.o
 obj-y			+= power/
 obj-$(CONFIG_ISA)	+= isa.o
 obj-$(CONFIG_FW_LOADER)	+= firmware_class.o
--- gregkh-2.6.orig/drivers/base/base.h
+++ gregkh-2.6/drivers/base/base.h
@@ -43,4 +43,5 @@ struct class_device_attribute *to_class_
 }
 
 extern char *make_class_name(const char *name, struct kobject *kobj);
+extern int virtual_device_parent(struct device *dev);
 
--- gregkh-2.6.orig/drivers/base/core.c
+++ gregkh-2.6/drivers/base/core.c
@@ -374,6 +374,13 @@ int device_add(struct device *dev)
 	if (!dev || !strlen(dev->bus_id))
 		goto Error;
 
+	/* if this is a class device, and has no parent, create one */
+	if ((dev->class) && (dev->parent == NULL)) {
+		error = virtual_device_parent(dev);
+		if (error)
+			goto Error;
+	}
+
 	parent = get_device(dev->parent);
 
 	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
@@ -419,7 +426,7 @@ int device_add(struct device *dev)
 				  "subsystem");
 		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
 				  dev->bus_id);
-		if (parent) {
+		if ((parent) && (!dev->virtual)) {
 			sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
 			class_name = make_class_name(dev->class->name, &dev->kobj);
 			sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
@@ -547,7 +554,7 @@ void device_del(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);
 		class_name = make_class_name(dev->class->name, &dev->kobj);
-		if (parent) {
+		if ((parent) && (!dev->virtual)) {
 			sysfs_remove_link(&dev->kobj, "device");
 			sysfs_remove_link(&dev->parent->kobj, class_name);
 		}
--- /dev/null
+++ gregkh-2.6/drivers/base/virtual.c
@@ -0,0 +1,142 @@
+/*
+ * virtual.c
+ *
+ * (C) Copyright 2006 Greg Kroah-Hartman
+ * (C) Copyright 2006 Novell Inc.
+ *
+ * Creates and manages the sysfs devices/virtual/ interface for devices
+ * that are associated with classes, yet do not have a "real" device as
+ * a parent.
+ *
+ * Licensed under the GPL version 2.
+ *
+ */
+#include <linux/device.h>
+#include <linux/err.h>
+#include "base.h"
+
+
+static struct device *virtual_dev;
+
+static void virtual_dev_release(struct device *dev)
+{
+	pr_debug("%s called for %s\n", __FUNCTION__, dev->bus_id);
+	kfree(dev);
+}
+
+static int init_virtual_device(void)
+{
+	int retval = 0;
+
+	if (virtual_dev != NULL)
+		goto exit;
+
+	virtual_dev = kzalloc(sizeof(*virtual_dev), GFP_KERNEL);
+	if (!virtual_dev) {
+		retval = -ENOMEM;
+		goto exit;
+	}
+	snprintf(virtual_dev->bus_id, BUS_ID_SIZE, "virtual");
+	virtual_dev->release = virtual_dev_release;
+
+	retval = device_register(virtual_dev);
+	if (retval)
+		goto error;
+
+exit:
+	return retval;
+
+error:
+	kfree(virtual_dev);
+	virtual_dev = NULL;
+	return retval;
+}
+
+
+static struct device *next_device(struct klist_iter *i)
+{
+	struct klist_node *n = klist_next(i);
+	return n ? container_of(n, struct device, knode_parent) : NULL;
+}
+
+static struct device *find_child_device(struct device *dev, const char *name)
+{
+	struct klist_iter i;
+	struct device *found_device = NULL;
+	struct device *child;
+
+	klist_iter_init(&dev->klist_children, &i);
+	while ((child = next_device(&i)) && !found_device) {
+		if (strcmp(child->bus_id, name) == 0)
+			found_device = get_device(child);
+	}
+	klist_iter_exit(&i);
+	return found_device;
+}
+
+static struct device *find_device_for_class(const char *class_name)
+{
+	struct device *dev = NULL;
+	int retval;
+
+	/* create a struct device for this name, if we can't find it
+	 * in the list of children for the virtual device.
+	 */
+
+	dev = find_child_device(virtual_dev, class_name);
+	if (dev)
+		goto exit;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		goto exit;
+
+	dev->parent = virtual_dev;
+	dev->release = virtual_dev_release;
+	snprintf(dev->bus_id, BUS_ID_SIZE, class_name);
+	retval = device_register(dev);
+	if (retval)
+		goto error;
+
+exit:
+	return dev;
+
+error:
+	kfree(dev);
+	return ERR_PTR(retval);
+}
+
+
+/**
+ * virtual_device_parent - create a proper parent for virtual devices
+ * dev: the struct device that the parent should be set for
+ *
+ * This function is used for devices that are associated with a class,
+ * yet has no "real" parent associated with them.  It will create a
+ * device/virtual/CLASS_NAME directory for them to be placed into,
+ * creating that directory if needed.
+ */
+int virtual_device_parent(struct device *dev)
+{
+	int retval;
+	struct device *parent;
+
+	if (!dev->class)
+		return -ENODEV;
+
+	retval = init_virtual_device();
+	if (retval)
+		goto exit;
+
+	parent = find_device_for_class(dev->class->name);
+	if (IS_ERR(parent)) {
+		retval = PTR_ERR(parent);
+		goto exit;
+	}
+
+	dev->parent = parent;
+	dev->virtual = 1;
+
+exit:
+	return retval;
+}
--- gregkh-2.6.orig/include/linux/device.h
+++ gregkh-2.6/include/linux/device.h
@@ -351,6 +351,7 @@ struct device {
 	struct class		*class;		/* optional*/
 	dev_t			devt;		/* dev_t, creates the sysfs "dev" */
 	struct attribute_group	**groups;	/* optional groups */
+	unsigned int		virtual:1;	/* if this is a "virtual" device or not */
 
 	void	(*release)(struct device * dev);
 };
