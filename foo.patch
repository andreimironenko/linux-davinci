---
 drivers/base/core.c    |   44 +++++++++++++++++++++++++++++++++++++++++---
 include/linux/device.h |    1 +
 2 files changed, 42 insertions(+), 3 deletions(-)

--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -475,6 +475,7 @@ void device_initialize(struct device *de
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	INIT_LIST_HEAD(&dev->node);
+	INIT_LIST_HEAD(&dev->virtual_dirs);
 	init_MUTEX(&dev->sem);
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);
@@ -512,12 +513,46 @@ static struct kobject * virtual_device_p
 	return dev->class->virtual_dir;
 }
 
+struct device_virtual_dir {
+	struct list_head	list;
+	struct kobject		*kobj;
+};
+
+static struct kobject *find_virtual_dir(struct device *dev, const char *name)
+{
+	struct device_virtual_dir *vd;
+	list_for_each_entry(vd, &dev->virtual_dirs, list) {
+		if (strcmp(kobject_name(vd->kobj), name) == 0)
+			return vd->kobj;
+	}
+	return NULL;
+}
+
 static struct kobject * get_device_parent(struct device *dev,
 					  struct device *parent)
 {
-	/* if this is a class device, and has no parent, create one */
-	if ((dev->class) && (parent == NULL)) {
-		return virtual_device_parent(dev);
+	struct device_virtual_dir *vd;
+	struct kobject *kobj;
+
+	if (dev->class) {
+		/* if has no parent, create a "virtual" one */
+		if (parent == NULL)
+			return virtual_device_parent(dev);
+
+		/* See if this parent already has the needed virtual directory */
+		kobj = find_virtual_dir(parent, dev->class->name);
+		if (kobj)
+			return kobj;
+
+		/* Has a real parent, but need to "sneak" a class named parent in the tree */
+		vd = kmalloc(sizeof(*vd), GFP_KERNEL);
+		if (!vd)
+			return ERR_PTR(-ENOMEM);
+		vd->kobj = kobject_add_dir(&parent->kobj, dev->class->name);
+		if (!vd->kobj)
+			return NULL;
+		list_add_tail(&parent->virtual_dirs, &vd->list);
+		return vd->kobj;
 	} else if (parent)
 		return &parent->kobj;
 	return NULL;
@@ -766,6 +801,7 @@ void device_del(struct device * dev)
 {
 	struct device * parent = dev->parent;
 	struct class_interface *class_intf;
+	struct device_virtual_dir *vd, *temp_vd;
 
 	if (parent)
 		klist_del(&dev->knode_parent);
@@ -773,6 +809,8 @@ void device_del(struct device * dev)
 		device_remove_file(dev, dev->devt_attr);
 		kfree(dev->devt_attr);
 	}
+	list_for_each_entry_safe(vd, temp_vd, &dev->virtual_dirs, list)
+		kfree(vd);
 	if (dev->class) {
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		/* If this is not a "fake" compatible device, remove the
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -449,6 +449,7 @@ struct device {
 
 	/* class_device migration path */
 	struct list_head	node;
+	struct list_head	virtual_dirs;
 	struct class		*class;
 	dev_t			devt;		/* dev_t, creates the sysfs "dev" */
 	struct attribute_group	**groups;	/* optional groups */
