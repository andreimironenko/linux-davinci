From foo@baz Tue Apr  9 12:12:43 2002
Date: Tue, 18 Jul 2006 10:59:59 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Driver Core: add ability for drivers to do a threaded probe

NOTE!  This turns on multhreaded probe for all PCI drivers.

It has NOT been tested on a multi-processor machine yet, use at your own risk.


Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/base/dd.c        |  101 ++++++++++++++++++++++++++++++++++-------------
 drivers/pci/pci-driver.c |    1 
 drivers/scsi/ata_piix.c  |    5 +-
 include/linux/device.h   |    2 
 4 files changed, 82 insertions(+), 27 deletions(-)

--- gregkh-2.6.orig/drivers/base/dd.c
+++ gregkh-2.6/drivers/base/dd.c
@@ -17,6 +17,7 @@
 
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/kthread.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -51,32 +52,23 @@ void device_bind_driver(struct device * 
 	sysfs_create_link(&dev->kobj, &dev->driver->kobj, "driver");
 }
 
-/**
- *	driver_probe_device - attempt to bind device & driver.
- *	@drv:	driver.
- *	@dev:	device.
- *
- *	First, we call the bus's match function, if one present, which
- *	should compare the device IDs the driver supports with the
- *	device IDs of the device. Note we don't do this ourselves
- *	because we don't know the format of the ID structures, nor what
- *	is to be considered a match and what is not.
- *
- *	This function returns 1 if a match is found, an error if one
- *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
- *
- *	This function must be called with @dev->sem held.  When called
- *	for a USB interface, @dev->parent->sem must be held as well.
- */
-int driver_probe_device(struct device_driver * drv, struct device * dev)
+struct stupid_thread_structure {
+	struct device_driver *drv;
+	struct device *dev;
+};
+
+static atomic_t count = ATOMIC_INIT(0);
+
+static int really_probe(void *void_data)
 {
+	struct stupid_thread_structure *data = void_data;
+	struct device_driver *drv = data->drv;
+	struct device *dev = data->dev;
 	int ret = 0;
 
-	if (drv->bus->match && !drv->bus->match(dev, drv))
-		goto Done;
-
-	pr_debug("%s: Matched Device %s with Driver %s\n",
-		 drv->bus->name, dev->bus_id, drv->name);
+	atomic_inc(&count);
+	printk("GREG: %s: enter: count = %d driver = %s device = %s\n",
+		__FUNCTION__, count.counter, drv->name, dev->bus_id);
 	dev->driver = drv;
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
@@ -93,11 +85,12 @@ int driver_probe_device(struct device_dr
 	}
 	device_bind_driver(dev);
 	ret = 1;
-	pr_debug("%s: Bound Device %s to Driver %s\n",
+//	pr_debug("%s: Bound Device %s to Driver %s\n",  FIXME
+	printk("%s: Bound Device %s to Driver %s\n",
 		 drv->bus->name, dev->bus_id, drv->name);
 	goto Done;
 
- ProbeFailed:
+ProbeFailed:
 	if (ret == -ENODEV || ret == -ENXIO) {
 		/* Driver matched, but didn't support device
 		 * or device not found.
@@ -110,7 +103,63 @@ int driver_probe_device(struct device_dr
 		       "%s: probe of %s failed with error %d\n",
 		       drv->name, dev->bus_id, ret);
 	}
- Done:
+Done:
+	kfree(data);
+	printk("GREG: %s:  exit: count = %d driver = %s device = %s\n",
+		__FUNCTION__, count.counter, drv->name, dev->bus_id);
+	atomic_dec(&count);
+	return ret;
+}
+
+int driver_probe_done(void)
+{
+	printk("GREG: %s: count = %d\n", __FUNCTION__, count.counter);
+	if (atomic_read(&count))
+		return -EBUSY;
+	return 0;
+}
+
+/**
+ *	driver_probe_device - attempt to bind device & driver.
+ *	@drv:	driver.
+ *	@dev:	device.
+ *
+ *	First, we call the bus's match function, if one present, which
+ *	should compare the device IDs the driver supports with the
+ *	device IDs of the device. Note we don't do this ourselves
+ *	because we don't know the format of the ID structures, nor what
+ *	is to be considered a match and what is not.
+ *
+ *	This function returns 1 if a match is found, an error if one
+ *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
+ *
+ *	This function must be called with @dev->sem held.  When called
+ *	for a USB interface, @dev->parent->sem must be held as well.
+ */
+int driver_probe_device(struct device_driver * drv, struct device * dev)
+{
+	struct stupid_thread_structure *data;
+	struct task_struct *probe_task;
+	int ret = 0;
+
+	if (drv->bus->match && !drv->bus->match(dev, drv))
+		goto Done;
+
+	pr_debug("%s: Matched Device %s with Driver %s\n",
+		 drv->bus->name, dev->bus_id, drv->name);
+
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	data->drv = drv;
+	data->dev = dev;
+
+	if (drv->multithread_probe) {
+		probe_task = kthread_run(really_probe, data, "probe");
+		if (IS_ERR(probe_task))
+			ret = PTR_ERR(probe_task);
+	} else
+		ret = really_probe(data);
+
+Done:
 	return ret;
 }
 
--- gregkh-2.6.orig/drivers/pci/pci-driver.c
+++ gregkh-2.6/drivers/pci/pci-driver.c
@@ -422,6 +422,7 @@ int __pci_register_driver(struct pci_dri
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.owner = owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
+	drv->driver.multithread_probe = 1;
 
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);
--- gregkh-2.6.orig/drivers/scsi/ata_piix.c
+++ gregkh-2.6/drivers/scsi/ata_piix.c
@@ -208,6 +208,9 @@ static struct pci_driver piix_pci_driver
 	.remove			= ata_pci_remove_one,
 	.suspend		= ata_pci_device_suspend,
 	.resume			= ata_pci_device_resume,
+	.driver	= {
+		.multithread_probe = 1,
+	},
 };
 
 static struct scsi_host_template piix_sht = {
@@ -945,7 +948,7 @@ static int __init piix_init(void)
 	if (rc)
 		return rc;
 
-	in_module_init = 0;
+	//in_module_init = 0;
 
 	DPRINTK("done\n");
 	return 0;
--- gregkh-2.6.orig/include/linux/device.h
+++ gregkh-2.6/include/linux/device.h
@@ -105,6 +105,8 @@ struct device_driver {
 	void	(*shutdown)	(struct device * dev);
 	int	(*suspend)	(struct device * dev, pm_message_t state);
 	int	(*resume)	(struct device * dev);
+
+	unsigned int multithread_probe:1;
 };
 
 
